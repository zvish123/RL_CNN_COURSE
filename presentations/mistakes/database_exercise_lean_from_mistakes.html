<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>××¦×’×ª ×œ××™×“×” - ×©×’×™××•×ª ×‘×ª×›× ×•×ª Database</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: grid;
            grid-template-columns: 1fr 1fr;
            min-height: 90vh;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                min-height: auto;
            }
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        /* Left Panel - Question */
        .left-panel {
            padding: 40px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            border-right: 1px solid #eee;
        }

        @media (max-width: 1024px) {
            .left-panel {
                border-right: none;
                border-bottom: 1px solid #eee;
            }
        }

        .question-header {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .question-header h2 {
            color: #667eea;
            font-size: 1.3em;
            margin-bottom: 5px;
        }

        .question-header p {
            color: #666;
            font-size: 0.9em;
        }

        .category-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            margin-bottom: 10px;
            margin-right: 8px;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            margin-right: 8px;
        }

        .difficulty-easy {
            background: #d4edda;
            color: #155724;
        }

        .difficulty-medium {
            background: #fff3cd;
            color: #856404;
        }

        .difficulty-hard {
            background: #f8d7da;
            color: #721c24;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            overflow-x: auto;
            margin: 20px 0;
            line-height: 1.5;
            direction:ltr;
        }

        .code-comment {
            color: #6a9955;
        }

        .code-string {
            color: #ce9178;
        }

        .code-keyword {
            color: #569cd6;
        }

        .code-function {
            color: #dcdcaa;
        }

        /* Question Info */
        .question-info {
            margin: 20px 0;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .question-info strong {
            color: #667eea;
        }

        /* Buttons */
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: auto;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn-reveal {
            background: #28a745;
            color: white;
            flex: 1;
            min-width: 150px;
        }

        .btn-reveal:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }

        .btn-reveal:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .btn-next {
            background: #667eea;
            color: white;
            flex: 1;
            min-width: 150px;
        }

        .btn-next:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-prev {
            background: #6c757d;
            color: white;
            flex: 0.5;
            min-width: 100px;
        }

        .btn-prev:hover {
            background: #5a6268;
        }

        /* Right Panel - Answer */
        .right-panel {
            padding: 40px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            background: #f9f9f9;
        }

        .answer-hidden {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: #999;
        }

        .answer-hidden h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .answer-hidden p {
            font-size: 1.1em;
        }

        .answer-revealed {
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .answer-section {
            margin-bottom: 30px;
        }

        .answer-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .explanation {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            line-height: 1.7;
            color: #333;
        }

        .explanation strong {
            color: #667eea;
        }

        .explanation em {
            color: #28a745;
        }

        .key-learning {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }

        .key-learning strong {
            color: #1976d2;
        }

        .avoid-list {
            background: #ffe7e7;
            border-left: 4px solid #d32f2f;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }

        .avoid-list strong {
            color: #c62828;
        }

        /* Progress Bar */
        .progress-bar {
            grid-column: 1 / -1;
            background: white;
            padding: 20px 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            border-top: 1px solid #eee;
        }

        .progress-text {
            font-weight: bold;
            color: #333;
            min-width: 200px;
        }

        .progress-fill {
            flex: 1;
            height: 30px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
        }

        .progress-inner {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            transition: width 0.5s ease;
        }

        .score-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2em;
            min-width: 150px;
            text-align: center;
        }

        /* Topics Overview */
        .topics-section {
            grid-column: 1 / -1;
            background: #f9f9f9;
            padding: 30px;
            border-top: 1px solid #eee;
            display: none;
        }

        .topics-section.show {
            display: block;
        }

        .topics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .topic-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .topic-card h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .topic-card ul {
            list-style: none;
            padding: 0;
        }

        .topic-card li {
            padding: 5px 0;
            color: #666;
            font-size: 0.9em;
        }

        .topic-card li:before {
            content: "âœ“ ";
            color: #28a745;
            font-weight: bold;
            margin-right: 5px;
        }

        /* Navigation */
        .nav-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .stats {
            grid-column: 1 / -1;
            background: white;
            padding: 20px 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            border-top: 1px solid #eee;
            display: none;
        }

        .stats.show {
            display: grid;
        }

        .stat-item {
            text-align: center;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .stat-item h4 {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .stat-item .number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-item .percentage {
            font-size: 0.9em;
            color: #999;
            margin-top: 5px;
        }

        /* Finished Screen */
        .finished-screen {
            display: none;
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 60px 30px;
            text-align: center;
        }

        .finished-screen.show {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }

        .finished-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
        }

        .finished-screen .final-score {
            font-size: 2.5em;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.2);
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .reset-button {
            background: white;
            color: #667eea;
            padding: 15px 40px;
            font-size: 1.1em;
            margin-top: 20px;
        }

        .reset-button:hover {
            background: #f0f0f0;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>ğŸ“ ××¦×’×ª ×œ××™×“×” - ×©×’×™××•×ª ×‘×ª×›× ×•×ª Database</h1>
            <p>×‘×—×Ÿ ××ª ×¢×¦××š - ××¦× ××ª ×”×©×’×™××” ×‘×§×•×“!</p>
        </div>

        <!-- Left Panel - Question -->
        <div class="left-panel">
            <div class="question-header">
                <span class="category-badge" id="categoryBadge">Locking</span>
                <span class="difficulty-badge difficulty-easy" id="difficultyBadge">×§×œ</span>
                <h2 id="questionNumber">×©××œ×” 1 ××ª×•×š 15</h2>
            </div>

            <div class="question-info">
                <strong>ğŸ“š × ×•×©×:</strong>
                <p id="topic">×©×’×™××•×ª ×‘× ×™×”×•×œ × ×¢×™×œ×•×ª</p>
            </div>

            <div>
                <h3>â“ ×”×©××œ×”:</h3>
                <p id="questionText" style="margin: 15px 0; line-height: 1.7; color: #333;"></p>
            </div>

            <div>
                <h3>ğŸ“ ×§×•×“ ×œ×‘×“×™×§×”:</h3>
                <div class="code-block" id="codeBlock"></div>
            </div>

            <div class="question-info">
                <strong>ğŸ’¡ ×¨××–:</strong>
                <p id="hint"></p>
            </div>

            <div class="button-group">
                <button class="btn-prev" id="prevBtn" onclick="previousQuestion()">â†’ ×”×§×•×“××ª</button>
                <button class="btn-reveal" id="revealBtn" onclick="revealAnswer()">×’×œ×” ××ª ×”×ª×©×•×‘×”</button>
                <button class="btn-next" id="nextBtn" onclick="nextQuestion()">×”×‘××” â†</button>
            </div>
        </div>

        <!-- Right Panel - Answer -->
        <div class="right-panel">
            <div class="answer-hidden" id="answerHidden">
                <h3>ğŸ”’ ×”×ª×©×•×‘×” × ×¢×•×œ×”</h3>
                <p>×œ×—×¥ ×¢×œ "×’×œ×” ××ª ×”×ª×©×•×‘×”" ×›×“×™ ×œ×¨××•×ª ××ª ×”×¤×ª×¨×•×Ÿ</p>
            </div>

            <div id="answerRevealed" style="display: none;">
                <div class="answer-section">
                    <h3>âš ï¸ ××” ×”×‘×¢×™×”?</h3>
                    <div class="explanation" id="problemExplanation"></div>
                </div>

                <div class="answer-section">
                    <h3>âœ… ×”×§×•×“ ×”×ª×§×™×Ÿ:</h3>
                    <div class="code-block" id="correctCode"></div>
                </div>

                <div class="answer-section">
                    <h3>ğŸ“ ××” ×œ×œ××•×“:</h3>
                    <div class="key-learning" id="keyPoints"></div>
                </div>

                <div class="answer-section">
                    <h3>âŒ ×ª×× ×¢ ×:</h3>
                    <div class="avoid-list" id="avoidList"></div>
                </div>

                <div class="answer-section" id="detailedExplanation"></div>
            </div>
        </div>

        <!-- Progress Bar -->
        <div class="progress-bar">
            <span class="progress-text">×”×ª×§×“××•×ª:</span>
            <div class="progress-fill">
                <div class="progress-inner" id="progressInner" style="width: 0%">
                    <span id="progressText">0%</span>
                </div>
            </div>
            <div class="score-box">
                <span id="scoreText">0/15</span>
            </div>
        </div>

        <!-- Topics Section -->
        <div class="topics-section" id="topicsSection">
            <h2 style="text-align: center; margin-bottom: 30px; color: #667eea;">ğŸ“š × ×•×©××™× × ×œ××“×•</h2>
            <div class="topics-grid" id="topicsGrid"></div>
        </div>

        <!-- Final Stats -->
        <div class="stats" id="statsSection">
            <div class="stat-item">
                <h4>×¡×”"×› ×©××œ×•×ª</h4>
                <div class="number">15</div>
            </div>
            <div class="stat-item">
                <h4>×ª×©×•×‘×•×ª × ×›×•× ×•×ª</h4>
                <div class="number" id="correctCount">0</div>
            </div>
            <div class="stat-item">
                <h4>××—×•×– ×”×¦×œ×—×”</h4>
                <div class="number" id="percentageScore">0%</div>
            </div>
            <div class="stat-item">
                <h4>×“×™×¨×•×’</h4>
                <div class="number" id="gradeScore">-</div>
            </div>
        </div>

        <!-- Finished Screen -->
        <div class="finished-screen" id="finishedScreen">
            <h1>ğŸ‰ ××¦×•×™×Ÿ!</h1>
            <p>×¡×™×™××ª ××ª ×›×œ ×”×©××œ×•×ª!</p>
            <div class="final-score" id="finalScore">0/15</div>
            <p id="finalMessage">××—×›×”...</p>
            <button class="reset-button" onclick="resetQuiz()">ğŸ”„ ×”×ª×—×œ ××—×“×©</button>
        </div>
    </div>

    <script>
        // ×©××œ×•×ª
        const questions = [
            // 1. Deadlock
            {
                id: 1,
                category: 'Locking',
                difficulty: '×§×œ',
                topic: '×©×’×™××•×ª ×‘× ×™×”×•×œ × ×¢×™×œ×•×ª',
                question: '××” ×”×‘×¢×™×” ×‘×§×•×“ ×”×‘×? Thread 1 ×× ×¡×” ×œ×”×©×™×’ lock1 ×•××—×¨ ×›×š lock2, ×‘×¢×•×“ Thread 2 ×× ×¡×” ×œ×”×©×™×’ lock2 ×•××—×¨ ×›×š lock1.',
                wrongCode: `class Question1:
    def __init__(self):
        self.lock1 = threading.Lock()
        self.lock2 = threading.Lock()
    
    def thread1_work(self):
        with self.lock1:
            print("T1: lock1")
            time.sleep(0.1)
            with self.lock2:
                print("T1: lock2")
    
    def thread2_work(self):
        with self.lock2:
            print("T2: lock2")
            time.sleep(0.1)
            with self.lock1:
                print("T2: lock1")`,
                problem: '×–×” ×™×’×¨×•× ×œ-DEADLOCK! Thread 1 ××—×–×™×§ lock1 ×•××—×›×” ×œ-lock2, ×‘×¢×•×“ Thread 2 ××—×–×™×§ lock2 ×•××—×›×” ×œ-lock1. ×”× ×—×•×¡××™× ××—×“ ××ª ×”×©× ×™ ×œ× ×¦×—.',
                correctCode: `class NoDeadlock:
    def __init__(self):
        self.lock1 = threading.Lock()
        self.lock2 = threading.Lock()
    
    def thread1_work(self):
        with self.lock1:
            print("T1: lock1")
            time.sleep(0.1)
            with self.lock2:
                print("T1: lock2")
    
    def thread2_work(self):
        # âœ… ××•×ª×• ×¡×“×¨! lock1 ×¨××©×•×Ÿ
        with self.lock1:
            print("T2: lock1")
            time.sleep(0.1)
            with self.lock2:
                print("T2: lock2")`,
                keyPoints: `âœ… ×ª××™×“ ××—×– locks ×‘×¡×“×¨ ×–×”×” ×‘×›×œ threads
âœ… ×ª×Ÿ ×©××•×ª ××œ×¤×‘×ª×™×™×: lock_a, lock_b
âœ… ×©×™××•×© ×‘lock ×™×—×™×“ ×”×•× ×¢×“×™×£ ×™×•×ª×¨`,
                avoidList: `âŒ ×¡×“×¨×™× ×©×•× ×™× ×©×œ locks ×‘threads ×©×•× ×™×
âŒ ×©×™××•×© ×‘×”×¨×‘×” locks ×œ×œ× ×¡×“×¨ ×‘×¨×•×¨
âŒ ×—×›×™×” ×œ×œ× timeout`,
                detailedExplanation: `<strong>×”×¡×™×‘×”:</strong> Deadlock ××ª×¨×—×© ×›××©×¨ ×©× ×™ threads ××—×–×™×§×™× resources ×•××—×›×™× ××—×“ ×œ×©× ×™.
<br><strong>×”×¤×ª×¨×•×Ÿ:</strong> ×ª××™×“ ××—×– locks ×‘×¡×“×¨ ×§×‘×•×¢ ×‘×¨×—×‘×™ ×”×§×•×“.
<br><strong>×”×ª×•×¦××”:</strong> ×‘×§×•×“ ×”×ª×§×™×Ÿ, Thread 1 ××§×‘×œ lock1, Thread 2 ××—×›×” ×œ-lock1, ×•××– ×”× ××ª× ×”×œ×™× ×‘×¡×“×¨.`,
                hint: '×©×™× ×œ×‘ ×œ×¡×“×¨ ×©×‘×• threads ×× ×¡×™× ×œ×”×©×™×’ locks.'
            },
            // 2. Race Condition
            {
                id: 2,
                category: 'Locking',
                difficulty: '×§×œ',
                topic: '× ×™×”×•×œ × ×¢×™×œ×•×ª',
                question: '×”××•× ×” ×¦×¨×™×š ×œ×”×™×•×ª 1000 ××‘×œ ×”×•× ×™×”×™×” ×”×¨×‘×” ×¤×—×•×ª. ××” ×”×‘×¢×™×”?',
                wrongCode: `class Counter:
    def __init__(self):
        self.count = 0
    
    def increment(self):
        temp = self.count
        temp = temp + 1
        self.count = temp

def worker():
    for _ in range(100):
        counter.increment()

# main
counter = Counter()
threads = [Thread(target=worker) for _ in range(10)]
for t in threads:
    t.start()
for t in threads:
    t.join()
print(counter.count)  # Expected: 1000`,
                problem: '×–×• race condition! ×œ× ×™×© lock, ××– threads ××¨×•×‘×™× ×™×›×•×œ×™× ×œ×§×¨×•×/×œ×›×ª×•×‘ ×‘×•-×–×× ×™×ª. Thread A ×§×•×¨× 0, Thread B ×§×•×¨× 0 (×‘××•×ª×• ×–××Ÿ!), ×©× ×™×”× ×›×•×ª×‘×™× 1. ×›×ª×•×¦××”: ×”×¡×¤×™×¨×” ×œ× × ×›×•× ×”.',
                correctCode: `class SafeCounter:
    def __init__(self):
        self.count = 0
        self.lock = threading.Lock()
    
    def increment(self):
        with self.lock:
            temp = self.count
            temp = temp + 1
            self.count = temp

def worker():
    for _ in range(100):
        counter.increment()

# main
counter = SafeCounter()
threads = [Thread(target=worker) for _ in range(10)]
for t in threads:
    t.start()
for t in threads:
    t.join()
print(counter.count)  # âœ… Always: 1000`,
                keyPoints: `âœ… Lock ×”×•× ×—×™×•× ×™ ×œ× ×ª×•× ×™× ××©×•×ª×¤×™×
âœ… ×›×œ ×¤×¢×•×œ×” read-modify-write ×¦×¨×™×›×” ×œ×”×™×•×ª atomic
âœ… with statement ××‘×˜×™×— ×©×—×¨×•×¨ lock`,
                avoidList: `âŒ read + compute + write ×œ×œ× lock
âŒ ×‘×“×™×§×” ××—×•×¥ ×œlock ×•×ª×”×œ×™×š ×‘×ª×•×š lock
âŒ ×”× ×—×” ×©-operations are atomic`,
                hint: '×ª×—×©×•×‘ ×¢×œ ××” ×§×•×¨×” ×›×©×©× ×™ threads ×§×•×¨××™× ××ª count ×‘×•-×–×× ×™×ª.',
                detailedExplanation: `<strong>Timeline ×©×œ Bug:</strong><br>T1: ×§×¨× count=0<br>T2: ×§×¨× count=0 (×–×” ××•×ª×• ×–××Ÿ!)<br>T1: compute 0+1=1<br>T2: compute 0+1=1<br>T1: ×›×ª×‘ count=1<br>T2: ×›×ª×‘ count=1<br>Result: 1 ×‘××§×•× 2!`
            },
            // 3. Writer Starvation
            {
                id: 3,
                category: 'Locking',
                difficulty: '×‘×™× ×•× ×™',
                topic: '× ×™×”×•×œ × ×¢×™×œ×•×ª',
                question: '××™×–×” ×‘×¢×™×” ×™×© ×‘×§×•×“ ×¢×‘×•×¨ writer?',
                wrongCode: `class BadRWLock:
    def __init__(self):
        self.active_readers = 0
        self.active_writer = False
        self.lock = threading.Lock()
        self.cond = threading.Condition(self.lock)
    
    def acquire_read(self):
        with self.cond:
            while self.active_writer:
                self.cond.wait()
            self.active_readers += 1
    
    def acquire_write(self):
        with self.cond:
            while self.active_readers > 0:
                self.cond.wait()
            self.active_writer = True
    
    def release_read(self):
        with self.cond:
            self.active_readers -= 1
            self.cond.notify_all()`,
                problem: 'Writer Priority - Readers Starvation, ×—×¡×¨ waiting_writers counter! Readers ×œ× ×™×•×“×¢×™× ×× ×™×© writer ×©××—×›×”. ××– readers ×—×“×©×™× ×××©×™×›×™× ×œ×”×›× ×¡ ×›×œ ×”×–××Ÿ ×•×‘writer ×œ× ××£ ×¤×¢× ××§×‘×œ ×”×¡×›××” (starvation).',
                correctCode: `class GoodRWLock:
    def __init__(self):
        self.active_readers = 0
        self.active_writer = False
        self.waiting_writers = 0  # âœ… KEY!
        self.lock = threading.Lock()
        self.cond = threading.Condition(self.lock)
    
    def acquire_read(self):
        with self.cond:
            # âœ… ×‘×“×•×§ waiting_writers!
            while self.active_writer or self.waiting_writers > 0:
                self.cond.wait()
            self.active_readers += 1
    
    def acquire_write(self):
        with self.cond:
            self.waiting_writers += 1  # âœ… Announce!
            try:
                while self.active_readers > 0 or self.active_writer:
                    self.cond.wait()
                self.active_writer = True
            finally:
                self.waiting_writers -= 1  # âœ… Always!
    
    def release_read(self):
        with self.cond:
            self.active_readers -= 1
            self.cond.notify_all()`,
                keyPoints: `âœ… waiting_writers counter ×”×•× ×—×™×•× ×™
âœ… Readers ×‘×“×•×§×™× waiting_writers > 0
âœ… Writers ××•×“×™×¢×™× ×›×©×”× ××—×›×™×
âœ… Finally block ×œ×ª××™×“ ×œ×”×¡×™×¨ ×-waiting_writers`,
                avoidList: `âŒ Readers ×©×œ× ×‘×•×“×§×™× waiting writers
âŒ Writers ×©×œ× ××•×“×™×¢×™× ×©×”× ××—×›×™×
âŒ ×‘×“×™×§×” ×œ×œ× update counters`,
                hint: 'Writer ×¦×¨×™×š ×œ×ª×Ÿ "signal" ×©-readers ×™×›×•×œ×™× ×œ×”×¨×’×™×©.',
                detailedExplanation: `<strong>Problem Sequence:</strong><br>1. Reader A ×‘×¢×‘×•×“×”<br>2. Writer W ×× ×¡×” ×›×ª×•×‘ - ××—×›×”<br>3. Reader B: "××™×Ÿ active_writer, ×× ×™ × ×›× ×¡!"<br>4. Writer W: ×¢×“×™×™×Ÿ ××—×›×”!<br><br><strong>Solution:</strong> waiting_writers counter ××’×™×“ ×œ-readers "×™×© writer ××—×›×”, ××œ ×ª×›× ×¡×•"`
            },
            // 4. Lock Leak
            {
                id: 4,
                category: 'Exception Handling',
                difficulty: '×‘×™× ×•× ×™',
                topic: 'Lock Leak - Exception',
                question: '×× risky_operation() ××©×œ×™×š exception, ××” ×§×•×¨×” ×œ-lock?',
                wrongCode: `class BadLockLeak:
    def __init__(self):
        self.lock = threading.Lock()
        self.data = {}
    
    def set_data(self, key, value):
        self.lock.acquire()
        self.data[key] = value
        risky_operation()  # âŒ Exception!
        self.lock.release()  # âŒ Never!

# âŒ ×‘×§×•×“ ××—×¨:
def another_thread():
    self.lock.acquire()  # âŒ HANGS FOREVER!`,
                problem: 'Lock leak! ×× risky_operation() ××©×œ×™×š exception, release() ×œ× ×§×•×¨×. Lock × ×©××¨ locked ×œ× ×¦×—. ×›×œ thread ×©×× ×¡×” ×œ×”×©×™×’ ××ª ×”-lock ×™×ª×§×¢ (deadlock).',
                correctCode: `class GoodLockSafe:
    def __init__(self):
        self.lock = threading.Lock()
        self.data = {}
    
    def set_data(self, key, value):
        # âœ… Option 1: Context Manager (BEST)
        with self.lock:
            self.data[key] = value
            risky_operation()  # Exception OK!
    
    def set_data_manual(self, key, value):
        # âœ… Option 2: Try-Finally
        self.lock.acquire()
        try:
            self.data[key] = value
            risky_operation()
        finally:
            self.lock.release()  # âœ… ALWAYS!`,
                keyPoints: `âœ… with statement ×”×•× ×”×ª×™×§×•×Ÿ ×”×˜×•×‘ ×‘×™×•×ª×¨
âœ… Try-finally ×× ×¦×¨×™×š manual acquire
âœ… Finally ×‘×œ×•×§ ×ª××™×“ ×¨×¥, ×’× ××—×¨×™ exception`,
                avoidList: `âŒ Manual acquire ×œ×œ× try-finally
âŒ Acquire ×‘×œ×™ to-do for release
âŒ ×”× ×—×” ×©×§×•×“ ×œ× ×™×© exceptions`,
                hint: 'Exception ××‘×˜×œ release(). ×¦×¨×™×š guarantee!',
                detailedExplanation: `<strong>Timeline ×©×œ Bug:</strong><br>T1: acquire()<br>T1: set data<br>T1: risky_operation() â†’ Exception!<br>T1: release() âŒ ×œ× ×§×•×¨×<br>T2: acquire() âŸ³ HANGS!<br><br><strong>Solution:</strong> with or try-finally ×ª××™×“ ××‘×˜×™×—×™× release`
            },
            // 5. Timeout Ignored
            {
                id: 5,
                category: 'Exception Handling',
                difficulty: '×‘×™× ×•× ×™',
                topic: 'Timeout Not Handled',
                question: '××” ×§×•×¨×” ×× acquire() timeout expire ××‘×œ ×§×•×“ ×××©×™×š?',
                wrongCode: `class BadTimeout:
    def __init__(self):
        self.lock = threading.Lock()
    
    def access_with_timeout(self, timeout):
        acquired = self.lock.acquire(timeout=timeout)
        
        # âŒ BUG: ×œ× ×‘×•×“×§×™× ×× acquired is False!
        print("Accessing resource...")
        protected_data = self.compute()  # âŒ RACE CONDITION!
        return protected_data

# Main:
lock.acquire()  # Lock ×™×“ holder
try_to_access_with_timeout(timeout=0.1)  # âŒ Timeout!`,
                problem: 'Timeout returned False ××‘×œ ×§×•×“ ×××©×™×š anyway! ×–×” race condition. ×× ×—× ×• ××’×™×©×™× protected data ×œ×œ× lock.',
                correctCode: `class GoodTimeout:
    def __init__(self):
        self.lock = threading.Lock()
    
    def access_with_timeout(self, timeout):
        acquired = self.lock.acquire(timeout=timeout)
        
        # âœ… Check!
        if not acquired:
            raise TimeoutError("Lock timeout")
        
        try:
            print("Accessing resource...")
            protected_data = self.compute()
            return protected_data
        finally:
            self.lock.release()`,
                keyPoints: `âœ… ×‘×“×•×§ ××ª return value: if not acquired
âœ… Raise exception ×× timeout
âœ… time.monotonic() ×¢×“×™×£ ×œaccuracy
âœ… Try-finally ×›×“×™ release`,
                avoidList: `âŒ ×ª×¢×œ× ×-False return
âŒ Access data ×œ×œ× lock
âŒ Forget to release`,
                hint: 'acquire() ××—×–×™×¨ bool - True or False.',
                detailedExplanation: `<strong>API Contract:</strong><br>acquire(timeout=0.1) returns:<br>â€¢ True = ×§×™×‘×œ× ×• lock<br>â€¢ False = timeout expired<br><br><strong>Bug:</strong> ×§×•×“ ××ª×¢×œ× ×-False!<br><strong>Fix:</strong> Check ×•-raise exception`
            },
            // 6. threading.Lock in Multiprocessing
            {
                id: 6,
                category: 'Multiprocessing',
                difficulty: '×‘×™× ×•× ×™',
                topic: 'Multiprocessing - threading.Lock ×œ× ×¢×•×‘×“',
                question: '×›××©×¨ ××©×ª××© threading.Lock ×‘×™×Ÿ processes, ×œ××” ×–×” ×œ× ×¢×•×‘×“?',
                wrongCode: `import multiprocessing as mp
import threading

class BadMultiLock:
    def __init__(self):
        self.lock = threading.Lock()  # âŒ WRONG!
        self.value = 0
    
    def increment(self):
        with self.lock:
            self.value += 1

def worker(obj):
    for _ in range(100):
        obj.increment()

if __name__ == "__main__":
    obj = BadMultiLock()
    processes = [
        mp.Process(target=worker, args=(obj,))
        for _ in range(4)
    ]
    for p in processes:
        p.start()
    for p in processes:
        p.join()
    print(obj.value)  # âŒ Expected: 400, Actual: ~87`,
                problem: 'threading.Lock ×¢×•×‘×“ ×¨×§ ×‘×ª×•×š process ×™×—×™×“! ×›×œ process ××§×‘×œ copy ×©×œ obj ×•lock ×©×œ×•. Locks ×œ× ××¡×ª× ×›×¨× ×™× ×‘×™×Ÿ processes! ×ª×•×¦××”: race conditions.',
                correctCode: `import multiprocessing as mp

class GoodMultiLock:
    def __init__(self, manager):
        self.lock = manager.Lock()  # âœ… Manager lock!
        self.value = manager.Value('i', 0)  # âœ… Shared!
    
    def increment(self):
        with self.lock:
            temp = self.value.value
            temp += 1
            self.value.value = temp

def worker(obj):
    for _ in range(100):
        obj.increment()

if __name__ == "__main__":
    manager = mp.Manager()  # âœ… Create first!
    obj = GoodMultiLock(manager)
    processes = [
        mp.Process(target=worker, args=(obj,))
        for _ in range(4)
    ]
    for p in processes:
        p.start()
    for p in processes:
        p.join()
    print(obj.value.value)  # âœ… Always: 400`,
                keyPoints: `âœ… threading.Lock ×¨×§ ×‘×ª×•×š process ××—×“
âœ… mp.Manager() ×œ×©×™×ª×•×£ ×‘×™×Ÿ processes
âœ… manager.Lock() ×•-manager.Value()
âœ… TCP Server ×”×“×¨×š ×”×˜×•×‘×” ×‘×™×•×ª×¨!`,
                avoidList: `âŒ threading.Lock ×‘×™×Ÿ processes
âŒ ×©×›×—×” ×œ×”×©×ª××© ×‘-Manager
âŒ ×œ×¢×‘×•×“ ×¢× shared data ×œ×œ× sync`,
                hint: 'Processes ××§×‘×œ×™× copies ×©×œ objects!',
                detailedExplanation: `<strong>Why?</strong> Processes ×”× independent. ×›×œ process ××§×‘×œ copy ×©×œ memory.<br><strong>threading.Lock:</strong> ×¨×§ ×‘×ª×•×š process<br><strong>Solution:</strong> mp.Manager() ×©××—×–×™×§ state centrally<br><strong>Best:</strong> TCP Server ×¢× single-threaded handler`
            },
            // 7. Socket Leak
            {
                id: 7,
                category: 'Sockets',
                difficulty: '×§×œ',
                topic: 'Socket Leak - Memory',
                question: '××“×•×¢ ×–×” ×’×•×¨× ×œmemory leak ×•×‘×¡×•×£ server ×§×•×¨×¡?',
                wrongCode: `class SocketLeak:
    def send_many(self, host, port, count):
        for i in range(count):
            sock = socket.socket()
            try:
                sock.connect((host, port))
                sock.sendall(f"Msg {i}".encode() + b"\\n")
                response = sock.recv(1024)
            except Exception as e:
                print(f"Error: {e}")
                # âŒ sock.close() NOT called!
            # âŒ If exception, socket NOT closed!

# âŒ Usage:
client = SocketLeak()
client.send_many("127.0.0.1", 5678, 1000)  # 1000 open sockets!`,
                problem: '×›×œ socket ×©×œ× ×¡×’×•×¨ × ×©××¨ ×‘memory. ×‘×¢×•×“ 1000 calls, ×™×© 1000 open sockets. Server ××§×‘×œ "too many open files" error ×•-crashes.',
                correctCode: `class SocketSafe:
    def send_many_safe(self, host, port, count):
        for i in range(count):
            # âœ… Option 1: Context Manager (BEST)
            with socket.create_connection((host, port)) as sock:
                sock.sendall(f"Msg {i}".encode() + b"\\n")
                response = sock.recv(1024)
            # âœ… Automatically closed!
    
    def send_many_try(self, host, port, count):
        # âœ… Option 2: Try-Finally
        for i in range(count):
            sock = socket.socket()
            try:
                sock.connect((host, port))
                sock.sendall(f"Msg {i}".encode() + b"\\n")
                response = sock.recv(1024)
            finally:
                sock.close()  # âœ… ALWAYS!`,
                keyPoints: `âœ… socket.create_connection() ×¢× with
âœ… Try-finally ×× manual
âœ… ×‘×“×•×§ ×¢×: lsof -p <pid>
âœ… Finally ×‘×œ×•×§ ×‘×˜×•×— ×©closed`,
                avoidList: `âŒ Forgetting to close
âŒ Close ×‘×œ×™ try-finally
âŒ Manual close ×‘×œ×™ protection`,
                hint: 'Exception ××‘×˜×œ×ª close().',
                detailedExplanation: `<strong>Count:</strong> lsof -p <pid> | wc -l<br><strong>Bug:</strong> 1000 calls = 1000 unclosed = memory leak<br><strong>Impact:</strong> "too many open files" error<br><strong>Fix:</strong> with or try-finally guarantee close`
            },
            // 8. Protocol Not Synchronized
            {
                id: 8,
                category: 'Sockets',
                difficulty: '×‘×™× ×•× ×™',
                topic: 'Socket Protocol - No Line Separator',
                question: '××“×•×¢ parser ×›×•×©×œ ×›××©×¨ ×œ× ×™×© newline separator ×‘protocol?',
                wrongCode: `def send_request(self, sock, data):
    msg = json.dumps(data)
    sock.sendall(msg.encode())  # âŒ No newline!

def read_response(self, sock):
    buffer = b""
    while len(buffer) < 1024:
        chunk = sock.recv(1024)
        buffer += chunk
        # âŒ How to know where message ends?
    
    try:
        return json.loads(buffer.decode())  # âŒ Might fail!
    except:
        # âŒ JSONDecodeError: partial data!
        pass`,
                problem: '×‘×œ×™ newline, ××™×¤×” ×”××¡×¨ ××¡×ª×™×™×? recv() ×™×›×•×œ ×œ×”×—×–×™×¨ partial, ××• multiple messages. Parser ×›×•×©×œ ××• ××§×‘×œ ×‘×œ×’×Ÿ.',
                correctCode: `def send_request(self, sock, data):
    msg = json.dumps(data)
    msg_with_newline = msg + "\\n"  # âœ… Add newline!
    sock.sendall(msg_with_newline.encode())

def read_response(self, sock):
    # âœ… Option 1: Read byte-by-byte until newline
    chunks = []
    while True:
        ch = sock.recv(1)
        if not ch:
            break
        if ch == b"\\n":
            break
        chunks.append(ch)
    
    line = b"".join(chunks).decode()
    return json.loads(line)  # âœ… Complete message!

# âœ… Option 2: Use makefile (cleaner)
def read_response_clean(self, sock):
    with sock.makefile('r') as f:
        line = f.readline()  # Reads until \\n
        return json.loads(line)`,
                keyPoints: `âœ… Line-based protocol: msg + "\\n"
âœ… Newline = end of message marker
âœ… makefile() ×¢×•×©×” socket ×œfile-like
âœ… Read byte-by-byte ×× ×¦×¨×™×š`,
                avoidList: `âŒ Binary protocol ×œ×œ× framing
âŒ ×©×™××•×© ×‘recv(4096) ×œ×œ× sync
âŒ Assuming messages are atomic`,
                hint: '××™×¤×” ××¡×¨ ××ª×—×™×œ ×•-××¡×ª×™×™×?',
                detailedExplanation: `<strong>Problem:</strong> TCP stream = bytes. ××™×Ÿ "messages"<br><strong>recv(1024):</strong> ×™×›×•×œ ×œ×”×—×–×™×¨ partial or multiple<br><strong>Solution:</strong> Protocol framing<br><strong>Simple:</strong> JSON + "\\n" = message<br><strong>Protocol:</strong> [length]:[data]\\n or JSON\\n`
            },
            // 9. Blocking Socket
            {
                id: 9,
                category: 'Sockets',
                difficulty: '×‘×™× ×•× ×™',
                topic: 'Blocking Socket - No Timeout',
                question: '××“×•×¢ server ×œ× ×™×›×•×œ ×œ×”×™×©×’× ×× client ×œ× ×©×•×œ×— ××• ×œ× ××•×¤×™×¢?',
                wrongCode: `def server_loop():
    server_sock = socket.socket()
    server_sock.bind(("127.0.0.1", 5678))
    server_sock.listen(1)
    
    while True:
        # âŒ No timeout!
        conn, addr = server_sock.accept()  # âŒ Hangs!
        
        # âŒ No timeout!
        data = conn.recv(1024)  # âŒ Hangs!
        
        if not data:
            # âŒ Connection closed, but maybe not all data?
            pass
        
        conn.close()

# âŒ If client doesn't connect or doesn't send:
# Server hangs forever! Can't shutdown!`,
                problem: '×œ×œ× timeout, accept() ×•-recv() ×™×—×›×• ×œ× ×¦×—. ×× client ×œ× ××•×¤×™×¢ ××• ×œ× ×©×•×œ×—, server ×ª×§×•×¢ (unresponsive). ×œ× ×™×›×•×œ ×œ×”×©×’×, ×œ× ×™×›×•×œ shutdown.',
                correctCode: `def server_loop():
    server_sock = socket.socket()
    server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_sock.bind(("127.0.0.1", 5678))
    server_sock.listen(1)
    
    # âœ… Set timeout!
    server_sock.settimeout(1.0)
    
    should_shutdown = False
    while not should_shutdown:
        try:
            # âœ… Will timeout every 1 second
            conn, addr = server_sock.accept()
        except socket.timeout:
            # âœ… Check if we should exit
            if should_shutdown:
                break
            continue
        
        # âœ… Handle in thread
        t = threading.Thread(target=handle_client, args=(conn,))
        t.start()

def handle_client(conn):
    conn.settimeout(5.0)  # âœ… Recv timeout too!
    try:
        while True:
            data = conn.recv(1024)
            if not data:
                break
            response = process(data)
            conn.sendall(response + b"\\n")
    except socket.timeout:
        print("Client timeout")
    finally:
        conn.close()`,
                keyPoints: `âœ… settimeout() ×¢×œ server ×•-client
âœ… Threading ×›×“×™ accept continues
âœ… Check empty recv = connection closed
âœ… Exception handling ×œ-socket.timeout`,
                avoidList: `âŒ Blocking socket ×œ×œ× timeout
âŒ Waiting ×œ×œ× check for shutdown
âŒ Main thread ×‘accepting`,
                hint: 'Main thread ×™×›×•×œ ×œ×”×™×•×ª blocked ×‘acceept() forever.',
                detailedExplanation: `<strong>Problem:</strong> accept() blocks forever<br><strong>Result:</strong> Server unresponsive<br><strong>Solution:</strong> settimeout() = check every N seconds<br><strong>Pattern:</strong> Main thread ×‘loop ×‘timeout, handle client ×‘thread`
            },
            // 10. Non-Atomic Write
            {
                id: 10,
                category: 'Persistence',
                difficulty: '×‘×™× ×•× ×™',
                topic: 'Atomic Write - File Corruption',
                question: '××“×•×¢ ×›×ª×™×‘×” ×™×©×™×¨×” ×œ×§×•×‘×¥ ×¢×œ×•×œ×” ×œ×’×¨×•× ×œcorruption?',
                wrongCode: `class NonAtomic:
    def save_data(self, path, data):
        # âŒ Direct overwrite - NOT safe!
        with open(path, "w") as f:
            json.dump(data, f)
        # âŒ If crash here, file is CORRUPTED!
        # âŒ If read during write, reader gets PARTIAL data!

# âŒ Reader:
def load_data(path):
    with open(path) as f:
        return json.load(f)  # âŒ JSONDecodeError!`,
                problem: '×× process ×§×•×¨×¡ ×‘×¢×•×“ ×›×ª×™×‘×”, ×§×•×‘×¥ corrupted. ×× reader ×§×•×¨××” ×‘×¢×•×“ writer ×›×•×ª×‘, reader ××§×‘×œ partial JSON (invalid). Result: crash or data loss.',
                correctCode: `class AtomicWrite:
    def __init__(self, path):
        self.path = path
        self.lock = threading.Lock()
    
    def save_data(self, data):
        with self.lock:  # âœ… Protect readers/writers
            # Step 1: Write to temp file
            directory = os.path.dirname(self.path) or "."
            fd, tmp = tempfile.mkstemp(dir=directory, prefix=".tmp_")
            
            try:
                # Step 2: Write data
                with os.fdopen(fd, "w") as f:
                    json.dump(data, f)
                    f.flush()
                    os.fsync(f.fileno())  # âœ… Force to disk!
                
                # Step 3: Atomic rename
                os.replace(tmp, self.path)  # âœ… Atomic!
            finally:
                # Step 4: Cleanup
                if os.path.exists(tmp):
                    try:
                        os.remove(tmp)
                    except:
                        pass
    
    def load_data(self):
        with self.lock:  # âœ… Wait for writes
            with open(self.path) as f:
                return json.load(f)`,
                keyPoints: `âœ… tempfile.mkstemp() = write to temp
âœ… fsync() = force to disk
âœ… os.replace() = atomic rename
âœ… threading.Lock = protect concurrent access
âœ… Finally = always cleanup`,
                avoidList: `âŒ Direct file overwrite
âŒ Write without fsync
âŒ No lock between readers/writers
âŒ No temp file`,
                hint: '×ª×›× ×Ÿ ×œ-crashes ×•-concurrent access.',
                detailedExplanation: `<strong>Scenarios:</strong><br>1. Crash during write = file truncated<br>2. Reader during write = partial JSON<br>3. No lock = corrupted state<br><br><strong>Solution:</strong> 3 steps:<br>1. Write to temp (safe)<br>2. fsync (durable)<br>3. Rename (atomic)<br><br><strong>Result:</strong> No corruption, no data loss`
            },
            // 11. Test Missing Concurrency
            {
                id: 11,
                category: 'Testing',
                difficulty: '×§×œ',
                topic: 'Bad Tests - Missing Concurrency',
                question: '××“×•×¢ ×–×” ×œ× test ×˜×•×‘ ×œ××¦×™××ª race conditions?',
                wrongCode: `def bad_test():
    db = Database()
    
    # âŒ ×–×” ×œ× test concurrency!
    db.set("key", "value")
    assert db.get("key") == "value"
    
    # âŒ ×–×” ×œ× test race conditions!
    # âŒ ×–×” ×œ× test timeout!
    # âŒ ×–×” ×œ× test persistence!
    
    # âŒ Test ×¢×•×‘×“ ××‘×œ ×œ× ××¦× bugs!`,
                problem: '×–×” single-threaded test! ×œ× ×‘×•×—×Ÿ concurrency, race conditions, ××• timeouts. ×œ× ××¦× bugs ×‘multi-threaded ×§×•×“.',
                correctCode: `def good_test_concurrent():
    db = Database()
    results = []
    errors = []
    
    def reader():
        try:
            for _ in range(50):
                value = db.get("key")
                results.append(value)
        except Exception as e:
            errors.append(e)
    
    # âœ… Multiple readers at once!
    threads = [threading.Thread(target=reader) for _ in range(10)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    
    assert len(errors) == 0, f"Errors: {errors}"
    assert len(results) == 500, f"Expected 500, got {len(results)}"

def good_test_timeout():
    am = AccessManager()
    
    # âœ… Acquire read lock
    assert am.acquire_read()
    
    # âœ… Try write with short timeout
    start = time.time()
    acquired = am.acquire_write(timeout=0.2)
    elapsed = time.time() - start
    
    # âœ… Should fail!
    assert not acquired, "Should timeout"
    assert 0.15 < elapsed < 0.25, f"Timeout: {elapsed}"
    
    am.release_read()

def good_test_persistence():
    db = Database("test.json")
    db.set("key", "value")
    
    # âœ… Create new instance - simulates restart
    db2 = Database("test.json")
    assert db2.get("key") == "value", "Data lost!"`,
                keyPoints: `âœ… Test concurrency ×¢× threads
âœ… Test timeout explicitly
âœ… Test persistence/recovery
âœ… Test edge cases (stress)
âœ… Test error conditions`,
                avoidList: `âŒ Only single-threaded tests
âŒ Happy path only
âŒ No edge cases
âŒ No error testing`,
                hint: 'Bugs ×‘concurrency ××•×¤×™×¢×™× ×ª×—×ª load.',
                detailedExplanation: `<strong>Key:</strong> Concurrency bugs ×œ× appear ×‘single-threaded!<br><strong>Solution:</strong> Threads + stress testing<br><strong>Timeout Test:</strong> Explicit timing verification<br><strong>Persistence:</strong> Simulate restart`
            },
            // 12. Writer Priority Test
            {
                id: 12,
                category: 'Testing',
                difficulty: '×‘×™× ×•× ×™',
                topic: 'Writer Priority - Proper Test',
                question: '××™×š ×œ×‘×—×•×Ÿ ×©writer priority ×¢×•×‘×“×ª?',
                wrongCode: `def bad_test():
    am = ReadWriteAccessManager()
    
    # âŒ ×œ× ×‘×•×“×§ writer priority ×‘×›×œ×œ!
    assert am.acquire_read()
    assert am.acquire_read()
    am.release_read()
    am.release_read()
    
    # âŒ ×–×” ×¨×§ ×‘×•×“×§ ×©readers ×¢×•×‘×“×™×
    # âŒ ×œ× ×‘×•×“×§ ×©writer ×—×•×¡× readers!`,
                problem: 'Test ×œ× ×‘×•×—×Ÿ ××ª ×”×“×‘×¨ ×”×—×©×•×‘: ×× writer ××—×›×”, readers ×—×“×©×™× ×¦×¨×™×›×™× ×œ×”×™×—×¡×. Test ×œ× ×›×•×©×œ ××¤×™×œ×• ×× writer priority ×œ× ××•××©××ª.',
                correctCode: `def good_test_writer_priority():
    am = ReadWriteAccessManager(max_readers=10)
    
    # Setup: ××—×“ reader
    assert am.acquire_read(timeout=0.5)  # Reader 1
    
    # Start thread: writer ×× ×¡×”
    writer_started = threading.Event()
    writer_acquired = threading.Event()
    
    def writer():
        writer_started.set()
        result = am.acquire_write(timeout=2.0)
        if result:
            writer_acquired.set()
        am.release_write()
    
    t = threading.Thread(target=writer)
    t.start()
    
    # Wait for writer to START trying
    assert writer_started.wait(timeout=1.0)
    time.sleep(0.05)
    
    # âœ… KEY TEST: New reader should be BLOCKED!
    start = time.time()
    acquired = am.acquire_read(timeout=0.2)
    elapsed = time.time() - start
    
    # âœ… Check: reader ×—×“×© ×¦×¨×™×š ×œ×”×™×—×¡×
    assert not acquired, "New reader should be blocked by waiting writer!"
    assert elapsed >= 0.18, "Should timeout after ~0.2s"
    
    # Release original reader so writer can proceed
    am.release_read()
    
    # âœ… Writer should now acquire
    assert writer_acquired.wait(timeout=1.0), "Writer should acquire"
    
    t.join(timeout=2.0)
    print("âœ… Writer priority test PASSED!")`,
                keyPoints: `âœ… Setup: reader ×‘×¢×‘×•×“×”
âœ… Start: writer thread ×× ×¡×”
âœ… Test: new reader should timeout
âœ… Verify: timing ×©×œ timeout
âœ… Release: original reader
âœ… Check: writer acquires`,
                avoidList: `âŒ Test ×©×œ× ×‘×•×“×§ priority
âŒ Test ×©×‘×•×“×§ ×¨×§ happy path
âŒ Test ×œ×œ× timing verification
âŒ Test ×œ×œ× concurrency`,
                hint: '×¦×¨×™×š ×‘×“×™×•×§ 3 participants: reader, writer, new reader.',
                detailedExplanation: `<strong>Test Design:</strong><br>1. Reader 1: acquire (holds)<br>2. Writer: try acquire (waits)<br>3. Reader 2: try acquire (should fail!)<br><br>If Reader 2 succeeds = bug!<br>If Reader 2 timeout = correct!`
            },
            // 13. Multiprocess Concurrency
            {
                id: 13,
                category: 'Multiprocessing',
                difficulty: '×§×©×”',
                topic: 'Multiprocess Test - Realistic',
                question: '××™×š ×œ×‘×—×•×Ÿ ×©××¨×•×‘×™× processes ×™×›×•×œ×™× ×œ×’×©×ª ×‘×•-×–×× ×™×ª ×œserver?',
                wrongCode: `def bad_test():
    # âŒ ×¦×¨×™×š ×œstartØ¡ server!
    # âŒ ×¦×¨×™×š ×œØ¹Ø¯Ø¯ processes!
    # âŒ ×¦×¨×™×š ×œ×‘×“×•×§ results!
    
    for i in range(10):
        # âŒ Sequential, ×œ× concurrent!
        client = DatabaseClient()
        client.set(f"key_{i}", i)`,
                problem: 'Test ×œ× ×‘×•×—×Ÿ concurrency ×‘×›×œ×œ! Test sequential, ×œ× concurrent. ×œ× ×™×’×œ×” race conditions ××• deadlocks ×‘multi-process.',
                correctCode: `def good_test_multiprocess():
    # Step 1: Start server ×‘process
    port = 5679
    server_proc = mp.Process(target=run_server, args=(port,))
    server_proc.start()
    
    # Wait for server
    time.sleep(0.5)
    
    try:
        # Step 2: Multiple processes access
        result_queues = [mp.Queue() for _ in range(5)]
        
        def client_worker(port, queue_idx, result_queue):
            try:
                client = DatabaseClient("127.0.0.1", port, timeout=5.0)
                for i in range(20):
                    # âœ… Each process does work
                    client.set(f"key_{queue_idx}_{i}", i)
                    value = client.get(f"key_{queue_idx}_{i}")
                    assert value == i
                result_queue.put(True)
            except Exception as e:
                result_queue.put(False)
                print(f"Error: {e}")
        
        # Create processes
        processes = [
            mp.Process(target=client_worker, args=(port, i, result_queues[i]))
            for i in range(5)
        ]
        
        # âœ… Start all at once
        start = time.time()
        for p in processes:
            p.start()
        
        # âœ… Wait with timeout
        for i, p in enumerate(processes):
            p.join(timeout=10.0)
            if p.is_alive():
                p.terminate()
                assert False, f"Process {i} timed out!"
        
        elapsed = time.time() - start
        
        # âœ… Check all succeeded
        for i, q in enumerate(result_queues):
            result = q.get(timeout=1.0)
            assert result, f"Process {i} failed!"
        
        print(f"âœ… All {len(processes)} processes completed in {elapsed:.2f}s")
    
    finally:
        server_proc.terminate()
        server_proc.join(timeout=2.0)`,
                keyPoints: `âœ… Start server ×‘process ××—×“
âœ… Multiple client processes
âœ… Each process does real work
âœ… Join with timeout
âœ… Check is_alive() ×œdeadlock
âœ… Cleanup: terminate + join`,
                avoidList: `âŒ Sequential testing
âŒ No server
âŒ No timeout on join
âŒ No cleanup`,
                hint: '×ª××™×“ ×™×© cleanup ×‘finally block.',
                detailedExplanation: `<strong>Pattern:</strong><br>1. Start server<br>2. Create client processes<br>3. Run concurrently<br>4. Verify results<br>5. Cleanup<br><br><strong>Key:</strong> is_alive() catches hangs!`
            },
            // 14. Conditional Variable Misuse
            {
                id: 14,
                category: 'Locking',
                difficulty: '×§×©×”',
                topic: 'Condition Variable - Wait Outside Lock',
                question: '××“×•×¢ ×¦×¨×™×š ×œ×”×™×©××¨ ×‘×¢×ª ×©×™××•×© ×‘condition variable?',
                wrongCode: `class BadCondition:
    def __init__(self):
        self.data = None
        self.cond = threading.Condition()
    
    def wait_for_data(self):
        # âŒ BUG: Wait ×‘×œ×™ ×œ×”×›× ×¡ ×œlock!
        # âŒ Wait() expects to already have lock!
        self.cond.wait()  # âŒ Race condition!
        return self.data
    
    def set_data(self, data):
        # âŒ BUG: Notify ×‘×œ×™ ×œ×”×›× ×¡ ×œlock!
        self.data = data
        self.cond.notify_all()  # âŒ Race condition!`,
                problem: 'Condition.wait() ×—×™×™×‘ ×œ×”×™×•×ª ×‘×ª×•×š lock! ×‘×œ×™ ×–×”, race condition ×‘×™×Ÿ check/wait. Notifier ×™×›×•×œ ×œ×”×•×“×™×¢ ×œ×¤× ×™ waiters × ×›× ×¡×™×.',
                correctCode: `class GoodCondition:
    def __init__(self):
        self.data = None
        self.lock = threading.Lock()
        self.cond = threading.Condition(self.lock)
    
    def wait_for_data(self):
        # âœ… Enter lock first!
        with self.cond:
            # âœ… Check while holding lock
            while self.data is None:
                # âœ… Wait releases lock, re-acquires on wake
                self.cond.wait()
            return self.data
    
    def set_data(self, data):
        # âœ… Enter lock first!
        with self.cond:
            self.data = data
            # âœ… Notify while holding lock
            self.cond.notify_all()`,
                keyPoints: `âœ… Condition Variable ×ª××™×“ ×‘×ª×•×š lock
âœ… with self.cond: = automatic lock
âœ… while loop ×œcheck, ×œ× if
âœ… notify ×‘×ª×•×š lock
âœ… wait() releases lock, re-acquires`,
                avoidList: `âŒ wait() ×‘×—×•×¥ lock
âŒ notify() ×‘×—×•×¥ lock
âŒ if statement ×‘××§×•× while
âŒ Assume notify reaches`,
                hint: 'wait() ×”×•× atomic ×¢× lock - releases ×‘wait, re-acquires ×œ×¤× ×™ returning.',
                detailedExplanation: `<strong>Protocol:</strong><br>1. Acquire lock<br>2. Check predicate<br>3. If false, wait (releases lock, sleeps)<br>4. Wake on notify (re-acquires lock)<br>5. Re-check predicate<br><br><strong>Why while?</strong> Spurious wakeups!`
            },
            // 15. File Handle Leak
            {
                id: 15,
                category: 'Resources',
                difficulty: '×§×œ',
                topic: 'File Handle Leak - Unclosed Files',
                question: '××“×•×¢ ×‘×¢×™×•×ª ×§×©×•×ª ×§×•×¨×•×ª ×›××©×¨ ×œ× ×¡×•×’×¨×™× files?',
                wrongCode: `class BadFileHandling:
    def read_many_files(self, filenames):
        results = []
        for filename in filenames:
            # âŒ No 'with' statement
            f = open(filename)
            # âŒ If exception here, file NOT closed!
            data = f.read()
            results.append(data)
            # âŒ f.close() never called if exception!
        return results
    
    def process_files(self, directory):
        # âŒ This calls read_many_files 1000 times
        # âŒ 1000 unclosed files!
        for filename in os.listdir(directory):
            results = self.read_many_files([filename])`,
                problem: 'Open file handles leak. ×‘×¢×•×“ 1000 iterations, ×™×© 1000 unclosed files. OS ××›×™×œ limit ×¢×œ open files. ×‘×¡×•×£: "too many open files" error, process crashes.',
                correctCode: `class GoodFileHandling:
    def read_many_files_safe(self, filenames):
        results = []
        for filename in filenames:
            # âœ… Option 1: Context Manager (BEST)
            with open(filename) as f:
                data = f.read()
                results.append(data)
            # âœ… Automatically closed!
        return results
    
    def read_many_files_try(self, filenames):
        # âœ… Option 2: Try-Finally
        results = []
        for filename in filenames:
            f = open(filename)
            try:
                data = f.read()
                results.append(data)
            finally:
                f.close()  # âœ… ALWAYS!
        return results
    
    def process_files_safe(self, directory):
        # âœ… Safe: files closed properly
        for filename in os.listdir(directory):
            results = self.read_many_files_safe([filename])`,
                keyPoints: `âœ… with statement = automatic close
âœ… Try-finally ×× manual open
âœ… Ø¨Ø¯ÙˆÙ† close = leak
âœ… Check: lsof -p <pid>`,
                avoidList: `âŒ Forgetting to close
âŒ Close ×‘×œ×™ try-finally
âŒ Manual close ×‘×œ×™ protection`,
                hint: '×›××• sockets - ×§×‘×¦×™× ×¦×¨×™×›×™× ×œ×”×™×¡×’×¨×™×.',
                detailedExplanation: `<strong>OS Limit:</strong> ulimit -n (1024 typical)<br><strong>Leak:</strong> 1000 calls = 1000 open<br><strong>Result:</strong> "too many open files"<br><strong>Fix:</strong> with or try-finally`
            }
        ];

        let currentQuestion = 0;
        let correctAnswers = 0;
        let revealedQuestions = new Set();

        function showQuestion(index) {
            if (index < 0) index = 0;
            if (index >= questions.length) index = questions.length - 1;

            currentQuestion = index;
            const q = questions[index];

            // Update question display
            document.getElementById('categoryBadge').textContent = q.category;
            document.getElementById('difficultyBadge').textContent = q.difficulty;
            document.getElementById('difficultyBadge').className = `difficulty-badge difficulty-${q.difficulty === '×§×œ' ? 'easy' : q.difficulty === '×‘×™× ×•× ×™' ? 'medium' : 'hard'}`;
            document.getElementById('questionNumber').textContent = `×©××œ×” ${index + 1} ××ª×•×š ${questions.length}`;
            document.getElementById('topic').textContent = q.topic;
            document.getElementById('questionText').textContent = q.question;
            document.getElementById('codeBlock').innerHTML = formatCode(q.wrongCode);
            document.getElementById('hint').textContent = q.hint;

            // Update answer display
            const revealed = revealedQuestions.has(index);
            document.getElementById('answerHidden').style.display = revealed ? 'none' : 'flex';
            document.getElementById('answerRevealed').style.display = revealed ? 'block' : 'none';

            if (revealed) {
                document.getElementById('problemExplanation').textContent = q.problem;
                document.getElementById('correctCode').innerHTML = formatCode(q.correctCode);
                document.getElementById('keyPoints').innerHTML = q.keyPoints.split('\n').join('<br>');
                document.getElementById('avoidList').innerHTML = q.avoidList.split('\n').join('<br>');

                if (q.detailedExplanation) {
                    document.getElementById('detailedExplanation').innerHTML = `
                        <h3>ğŸ“– ×”×¡×‘×¨ ××¤×•×¨×˜:</h3>
                        <div class="explanation">${q.detailedExplanation}</div>
                    `;
                }
            }

            // Update buttons
            document.getElementById('prevBtn').disabled = index === 0;
            document.getElementById('nextBtn').disabled = index === questions.length - 1;

            // Update progress
            updateProgress();

            // Scroll to top
            document.querySelector('.left-panel').scrollTop = 0;
            document.querySelector('.right-panel').scrollTop = 0;
        }

        function formatCode(code) {
            return `<pre>${code}</pre>`;
        }

        function revealAnswer() {
            if (!revealedQuestions.has(currentQuestion)) {
                revealedQuestions.add(currentQuestion);
                correctAnswers++;
            }
            showQuestion(currentQuestion);
        }

        function nextQuestion() {
            showQuestion(currentQuestion + 1);
        }

        function previousQuestion() {
            showQuestion(currentQuestion - 1);
        }

        function updateProgress() {
            const total = questions.length;
            const percentage = Math.round((correctAnswers / total) * 100);

            document.getElementById('scoreText').textContent = `${correctAnswers}/${total}`;
            document.getElementById('progressInner').style.width = percentage + '%';
            document.getElementById('progressText').textContent = percentage + '%';

            // Check if finished
            if (correctAnswers === total) {
                showFinished();
            }
        }

        function showFinished() {
            const percentage = (correctAnswers / questions.length) * 100;
            let grade = 'A+';
            let message = '××¢×•×œ×”! ×‘×—× ×ª ××ª ×¢×¦××š ×‘×”×¦×œ×—×”!';

            if (percentage < 50) {
                grade = 'F';
                message = '×”×ª×—×œ ××—×“×© - ×™×© ×”×¨×‘×” ××” ×œ×œ××•×“!';
            } else if (percentage < 70) {
                grade = 'C';
                message = '×˜×•×‘, ××‘×œ ×™×© ×¢×•×“ ××” ×œ×œ××•×“!';
            } else if (percentage < 85) {
                grade = 'B';
                message = '×˜×•×‘ ×××•×“! ××ª×” ×‘×“×¨×š ×”× ×›×•× ×”!';
            } else if (percentage < 95) {
                grade = 'A';
                message = '××¢×•×œ×”! ××ª×” ××‘×™×Ÿ ××ª ×”× ×•×©×!';
            }

            document.getElementById('finishedScreen').classList.add('show');
            document.getElementById('container').style.gridTemplateRows = 'auto 1fr';
            document.querySelector('.header').style.display = 'none';
            document.querySelector('.left-panel').style.display = 'none';
            document.querySelector('.right-panel').style.display = 'none';
            document.querySelector('.progress-bar').style.display = 'none';

            document.getElementById('finalScore').textContent = `${correctAnswers}/${questions.length}`;
            document.getElementById('finalMessage').textContent = message + ` (×“×™×¨×•×’: ${grade})`;

            // Show stats
            document.getElementById('statsSection').classList.add('show');
            document.getElementById('correctCount').textContent = correctAnswers;
            document.getElementById('percentageScore').textContent = Math.round(percentage) + '%';
            document.getElementById('gradeScore').textContent = grade;
        }

        function resetQuiz() {
            currentQuestion = 0;
            correctAnswers = 0;
            revealedQuestions.clear();

            document.getElementById('finishedScreen').classList.remove('show');
            document.querySelector('.header').style.display = 'block';
            document.querySelector('.left-panel').style.display = 'flex';
            document.querySelector('.right-panel').style.display = 'flex';
            document.querySelector('.progress-bar').style.display = 'flex';
            document.getElementById('statsSection').classList.remove('show');

            showQuestion(0);
        }

        // Initialize
        showQuestion(0);

        // Global functions
        window.revealAnswer = revealAnswer;
        window.nextQuestion = nextQuestion;
        window.previousQuestion = previousQuestion;
        window.resetQuiz = resetQuiz;
    </script>
</body>
</html>
