<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Zen of Python - מצגת לתלמידים</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .slide {
            background: rgba(255, 255, 255, 0.95);
            margin: 30px 0;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            animation: slideIn 0.8s ease-out;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .title-slide {
            text-align: center;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
        }
        
        h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            font-size: 1.5em;
            opacity: 0.9;
        }
        
        .zen-principle {
            font-size: 1.8em;
            color: #2c3e50;
            font-weight: bold;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(90deg, #74b9ff, #0984e3);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            border-right: 5px solid #74b9ff;
            padding-right: 20px;
        }
        
        .explanation {
            font-size: 1.3em;
            margin-bottom: 25px;
            color: #2c3e50;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border-right: 4px solid #6c5ce7;
        }
        
        .code-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            direction:ltr;
        }
        
        .code-good, .code-bad {
            padding: 20px;
            border-radius: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            position: relative;
            overflow-x: auto;
            direction:ltr;
        }
        
        .code-good {
            background: #d4edda;
            border: 2px solid #28a745;
        }
        
        .code-bad {
            background: #f8d7da;
            border: 2px solid #dc3545;
        }
        
        .code-good::before, .code-bad::before {
            position: absolute;
            top: 0px;
            right: 10px;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .code-good::before {
            content: "✅ מומלץ";
            background: #28a745;
            color: white;
        }
        
        .code-bad::before {
            content: "❌ לא מומלץ";
            background: #dc3545;
            color: white;
        }
        
        pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            direction:ltr;
        }
        
        .navigation {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        
        .nav-btn {
            padding: 10px 20px;
            background: #6c5ce7;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .nav-btn:hover {
            background: #5f3dc4;
            transform: translateY(-2px);
        }
        
        .nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .slide-counter {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 768px) {
            .code-section {
                grid-template-columns: 1fr;
            }
            
            .slide {
                padding: 20px;
                margin: 20px 0;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .zen-principle {
                font-size: 1.4em;
            }
            
            .explanation {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <div class="slide-counter">
        <span id="current-slide">1</span> / <span id="total-slides">21</span>
    </div>
    
    <div class="container">
        <!-- Slide 1: Title -->
        <div class="slide title-slide">
            <h1>The Zen of Python</h1>
            <p class="subtitle">העקרונות המנחים לכתיבת קוד Python טוב</p>
            <p style="margin-top: 20px; font-size: 1.2em;">מאת Tim Peters</p>
        </div>

        <!-- Slide 2: Introduction -->
        <div class="slide hidden">
            <h2 style="font-size: 2.5em; margin-bottom: 30px; color: #2c3e50;">מה זה ה-Zen of Python?</h2>
            <div class="explanation">
                <p>ה-Zen of Python הוא אוסף של 19 עקרונות מנחים לכתיבת קוד Python טוב וברור. העקרונות האלה נכתבו על ידי Tim Peters והם מסבירים את הפילוסופיה מאחורי שפת Python.</p>
                <br>
                <p><strong>איך לראות את ה-Zen בקוד Python:</strong></p>
                <pre style="background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 8px; margin-top: 10px;">
import this
                </pre>
            </div>
        </div>

        <!-- Slide 3: Principle 1 -->
        <div class="slide hidden">
            <div class="zen-principle">1. Beautiful is better than ugly</div>
            <div class="explanation">
                קוד יפה עדיף על קוד מכוער. קוד יפה הוא קוד שקריא, מאורגן וברור. הוא עוזר למתכנתים להבין את המטרה והלוגיקה בקלות.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># קוד יפה וברור
def calculate_circle_area(radius):
    """מחשב שטח עיגול לפי הרדיוס"""
    pi = 3.14159
    return pi * radius ** 2

# שימוש ברור
area = calculate_circle_area(5)
print(f"שטח העיגול: {area:.2f}")</pre>
                </div>
                
                <div class="code-bad">
                    <pre># קוד מכוער ולא ברור
def calc(r):
    return 3.14159*r*r

# שימוש לא ברור
a=calc(5)
print(a)</pre>
                </div>
            </div>
        </div>

        <!-- Slide 4: Principle 2 -->
        <div class="slide hidden">
            <div class="zen-principle">2. Explicit is better than implicit</div>
            <div class="explanation">
                עדיף להיות ברור ומפורש מאשר לסמוך על הבנות מרומזות. קוד מפורש מקל על הבנה ותחזוקה.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># מפורש וברור
from datetime import datetime
from math import sqrt

def process_data(data_list):
    """מעבד רשימת נתונים ומחזיר תוצאה"""
    processed_items = []
    for item in data_list:
        if item is not None:
            processed_items.append(sqrt(item))
    return processed_items

# שימוש מפורש
numbers = [1, 4, 9, 16]
results = process_data(numbers)</pre>
                </div>
                
                <div class="code-bad">
                    <pre># מרומז ולא ברור
from datetime import *
from math import *

def process_data(data):
    return [sqrt(x) for x in data if x]

# לא ברור מה קורה
results = process_data([1, 4, 9, 16])</pre>
                </div>
            </div>
        </div>

        <!-- Slide 5: Principle 3 -->
        <div class="slide hidden">
            <div class="zen-principle">3. Simple is better than complex</div>
            <div class="explanation">
                פתרונות פשוטים עדיפים על פתרונות מורכבים. פשטות מקלה על הבנה, בדיקה ותחזוקה של הקוד.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># פתרון פשוט
def is_even(number):
    """בודק אם מספר זוגי"""
    return number % 2 == 0

def filter_even_numbers(numbers):
    """מסנן מספרים זוגיים מרשימה"""
    return [num for num in numbers if is_even(num)]

# שימוש
nums = [1, 2, 3, 4, 5, 6]
even_nums = filter_even_numbers(nums)</pre>
                </div>
                
                <div class="code-bad">
                    <pre># פתרון מורכב מדי
def filter_numbers_by_parity(numbers, parity_func=None):
    if not parity_func:
        parity_func = lambda x: not bool(x & 1)
    
    class NumberFilter:
        def __init__(self, func):
            self.func = func
        
        def filter(self, nums):
            return list(filter(self.func, nums))
    
    return NumberFilter(parity_func).filter(numbers)</pre>
                </div>
            </div>
        </div>

        <!-- Slide 6: Principle 4 -->
        <div class="slide hidden">
            <div class="zen-principle">4. Complex is better than complicated</div>
            <div class="explanation">
                כשפתרון פשוט לא מספיק, עדיף פתרון מורכב אבל מאורגן על פתרון מסובך וחסר סדר. מורכבות מובנית עדיפה על בלגן.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># מורכב אבל מאורגן
class DataProcessor:
    def __init__(self):
        self.validators = []
        self.transformers = []
    
    def add_validator(self, validator):
        self.validators.append(validator)
    
    def add_transformer(self, transformer):
        self.transformers.append(transformer)
    
    def process(self, data):
        # validate
        for validator in self.validators:
            if not validator(data):
                raise ValueError("Invalid data")
        
        # transform
        for transformer in self.transformers:
            data = transformer(data)
        
        return data</pre>
                </div>
                
                <div class="code-bad">
                    <pre># מסובך וחסר סדר
def process_data(d,v1=None,v2=None,t1=None,t2=None,t3=None):
    if v1 and not v1(d): raise Exception()
    if v2 and not v2(d): raise Exception()
    if t1: d=t1(d)
    if t2: d=t2(d) 
    if t3: d=t3(d)
    return d

# או חמור מזה - קוד מסובך עם nested conditions
def messy_process(data):
    if data:
        if len(data) > 0:
            if isinstance(data, list):
                if all(isinstance(x, int) for x in data):
                    return [x*2 if x > 0 else x for x in data]</pre>
                </div>
            </div>
        </div>

        <!-- Slide 7: Principle 5 -->
        <div class="slide hidden">
            <div class="zen-principle">5. Flat is better than nested</div>
            <div class="explanation">
                עדיף מבנה שטוח על מבנה מקונן מדי. הרבה רמות של nesting הופכות את הקוד לקשה לקריאה ולהבנה.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># מבנה שטוח יותר
def process_user_data(user):
    if not user:
        return None
    
    if not user.get('email'):
        return None
    
    if not is_valid_email(user['email']):
        return None
    
    if user.get('age', 0) < 18:
        return None
    
    return create_account(user)

def is_valid_email(email):
    return '@' in email and '.' in email</pre>
                </div>
                
                <div class="code-bad">
                    <pre># מקונן מדי - קשה לקרוא
def process_user_data(user):
    if user:
        if user.get('email'):
            if '@' in user['email'] and '.' in user['email']:
                if user.get('age'):
                    if user['age'] >= 18:
                        if user.get('name'):
                            if len(user['name']) > 0:
                                return create_account(user)
                            else:
                                return None
                        else:
                            return None
                    else:
                        return None
                else:
                    return None
            else:
                return None
        else:
            return None
    else:
        return None</pre>
                </div>
            </div>
        </div>

        <!-- Slide 8: Principle 6 -->
        <div class="slide hidden">
            <div class="zen-principle">6. Sparse is better than dense</div>
            <div class="explanation">
                קוד מפוזר (עם רווחים ושורות ריקות) עדיף על קוד צפוף. זה עוזר לעיניים לנוח ולמוח להבין את המבנה.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># קוד מפוזר וברור
def calculate_statistics(numbers):
    """מחשב סטטיסטיקות בסיסיות לרשימת מספרים"""
    if not numbers:
        return None
    
    total = sum(numbers)
    count = len(numbers)
    average = total / count
    
    sorted_nums = sorted(numbers)
    middle = count // 2
    
    if count % 2 == 0:
        median = (sorted_nums[middle-1] + sorted_nums[middle]) / 2
    else:
        median = sorted_nums[middle]
    
    return {
        'average': average,
        'median': median,
        'total': total,
        'count': count
    }</pre>
                </div>
                
                <div class="code-bad">
                    <pre># קוד צפוף וקשה לקריאה
def calculate_statistics(numbers):
    if not numbers:return None
    total,count,average=sum(numbers),len(numbers),sum(numbers)/len(numbers)
    sorted_nums,middle=sorted(numbers),count//2
    median=(sorted_nums[middle-1]+sorted_nums[middle])/2 if count%2==0 else sorted_nums[middle]
    return {'average':average,'median':median,'total':total,'count':count}</pre>
                </div>
            </div>
        </div>

        <!-- Slide 9: Principle 7 -->
        <div class="slide hidden">
            <div class="zen-principle">7. Readability counts</div>
            <div class="explanation">
                קריאות זה חשוב! קוד נכתב פעם אחת אבל נקרא פעמים רבות. השקעה בקריאות חוסכת זמן רב בעתיד.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># קריא וברור
class ShoppingCart:
    """עגלת קניות עם פונקציונליות בסיסית"""
    
    def __init__(self):
        self.items = []
        self.discount_rate = 0.0
    
    def add_item(self, item_name, price, quantity=1):
        """מוסיף פריט לעגלה"""
        item = {
            'name': item_name,
            'price': price,
            'quantity': quantity
        }
        self.items.append(item)
    
    def calculate_total(self):
        """מחשב סכום כולל כולל הנחה"""
        subtotal = sum(
            item['price'] * item['quantity'] 
            for item in self.items
        )
        
        discount_amount = subtotal * self.discount_rate
        total = subtotal - discount_amount
        
        return total</pre>
                </div>
                
                <div class="code-bad">
                    <pre># לא קריא
class SC:
    def __init__(self):
        self.i=[]
        self.d=0.0
    def ai(self,n,p,q=1):
        self.i.append({'n':n,'p':p,'q':q})
    def ct(self):
        s=sum(x['p']*x['q'] for x in self.i)
        return s-s*self.d</pre>
                </div>
            </div>
        </div>

        <!-- Slide 10: Principle 8 -->
        <div class="slide hidden">
            <div class="zen-principle">8. Special cases aren't special enough to break the rules</div>
            <div class="explanation">
                מקרים מיוחדים לא מספיק מיוחדים כדי לשבור את הכללים. עקביות בסגנון הקוד חשובה יותר מאופטימיזציות מקומיות.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># עקבי עם הכללים
def validate_input(data):
    """validates different types of input consistently"""
    if data is None:
        return False
    
    if isinstance(data, str):
        return len(data.strip()) > 0
    
    if isinstance(data, (int, float)):
        return data >= 0
    
    if isinstance(data, list):
        return len(data) > 0 and all(validate_input(item) for item in data)
    
    return False

# שימוש עקבי
results = []
inputs = ["hello", 42, [], None, [1, 2, 3]]

for inp in inputs:
    if validate_input(inp):
        results.append(inp)</pre>
                </div>
                
                <div class="code-bad">
                    <pre># שוברים כללים למקרים "מיוחדים"
def validate_input(data):
    # "מקרה מיוחד" למחרוזות
    if isinstance(data, str):
        if data == "admin": return True  # יוצא דופן
        return len(data.strip()) > 0
    
    # "מקרה מיוחד" למספרים
    if isinstance(data, int):
        if data == -1: return True  # יוצא דופן
        return data >= 0
    
    return True if data else False  # סגנון שונה

# סגנון לא עקבי
valid_items = []
for inp in inputs:
    # לפעמים כך
    if validate_input(inp): valid_items.append(inp)
    
# לפעמים אחרת  
for inp in other_inputs:
    result = validate_input(inp)
    if result == True:
        valid_items.append(inp)</pre>
                </div>
            </div>
        </div>

        <!-- Slide 11: Principle 9 -->
        <div class="slide hidden">
            <div class="zen-principle">9. Although practicality beats purity</div>
            <div class="explanation">
                למרות שכללים חשובים, פרגמטיות מנצחת טוהר. לפעמים צריך לעשות את מה שעובד, גם אם זה לא "מושלם" תיאורטית.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># פרגמטי - עובד טוב במציאות
import os
import json

class ConfigManager:
    """מנהל הגדרות פרגמטי"""
    
    def __init__(self, config_file="config.json"):
        self.config_file = config_file
        self.config = {}
        self.load_config()
    
    def load_config(self):
        """טוען הגדרות מקובץ או יוצר ברירת מחדל"""
        try:
            with open(self.config_file, 'r') as f:
                self.config = json.load(f)
        except FileNotFoundError:
            # פרגמטי: יוצר הגדרות ברירת מחדל
            self.config = {
                "debug": False,
                "timeout": 30,
                "retries": 3
            }
            self.save_config()
        except json.JSONDecodeError:
            # פרגמטי: מתמודד עם קובץ פגום
            print("Config file corrupted, using defaults")
            self.config = {"debug": False, "timeout": 30}</pre>
                </div>
                
                <div class="code-bad">
                    <pre># "טהור" אבל לא מעשי
class ConfigManager:
    """מנהל הגדרות "טהור" - מסורבל מדי"""
    
    def __init__(self, config_source):
        if not isinstance(config_source, ConfigSource):
            raise TypeError("Must provide ConfigSource")
        self.source = config_source
    
    def load_config(self):
        try:
            return self.source.load()
        except ConfigLoadError as e:
            raise ConfigurationException(
                "Failed to load configuration"
            ) from e

# צריך הרבה מדי מחלקות "טהורות"
class ConfigSource(ABC):
    @abstractmethod
    def load(self): pass

class JSONConfigSource(ConfigSource):
    def load(self): pass

class ConfigLoadError(Exception): pass
class ConfigurationException(Exception): pass</pre>
                </div>
            </div>
        </div>

        <!-- Slide 12: Principle 10 -->
        <div class="slide hidden">
            <div class="zen-principle">10. Errors should never pass silently</div>
            <div class="explanation">
                שגיאות לא צריכות לעבור בדממה. כשמשהו משתבש, זה צריך להיות גלוי ומטופל בצורה מתאימה.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># מטפל בשגיאות בצורה נכונה
def divide_numbers(a, b):
    """מחלק שני מספרים עם טיפול בשגיאות"""
    if not isinstance(a, (int, float)):
        raise TypeError(f"First argument must be number, got {type(a)}")
    
    if not isinstance(b, (int, float)):
        raise TypeError(f"Second argument must be number, got {type(b)}")
    
    if b == 0:
        raise ValueError("Cannot divide by zero")
    
    return a / b

def safe_divide(a, b):
    """גרסה בטוחה של חלוקה"""
    try:
        return divide_numbers(a, b)
    except (TypeError, ValueError) as e:
        print(f"Error in division: {e}")
        return None

# שימוש מודע לשגיאות
result = safe_divide(10, 2)
if result is not None:
    print(f"Result: {result}")</pre>
                </div>
                
                <div class="code-bad">
                    <pre># מתעלם משגיאות - מסוכן!
def divide_numbers(a, b):
    try:
        return a / b
    except:
        pass  # שגיאה חמורה - מתעלם מכל שגיאה!

def process_data(data_list):
    results = []
    for item in data_list:
        try:
            processed = complex_calculation(item)
            results.append(processed)
        except:
            continue  # מתעלם מבעיות - לא יודע מה הולך רע!
    
    return results

# לא יודע אם הפונקציה עבדה או נכשלה
result = divide_numbers(10, 0)  # None - אבל למה?
data = process_data([1, "bad", 3])  # חלק מהנתונים נעלמים</pre>
                </div>
            </div>
        </div>

        <!-- Slide 13: Principle 11 -->
        <div class="slide hidden">
            <div class="zen-principle">11. Unless explicitly silenced</div>
            <div class="explanation">
                אלא אם השתקת את השגיאות במכוון. לפעמים אנחנו רוצים להתעלם משגיאות ספציפיות, אבל זה צריך להיות מכוון וברור.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># השתקה מכוונת ומתועדת
import logging

logger = logging.getLogger(__name__)

def load_optional_config(filename):
    """טוען קובץ הגדרות אופציונלי"""
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        # השתקה מכוונת - קובץ אופציונלי
        logger.info(f"Optional config file {filename} not found, using defaults")
        return {}
    except json.JSONDecodeError as e:
        # זה כבר לא אופציונלי - יש קובץ אבל פגום
        logger.error(f"Invalid JSON in config file: {e}")
        raise

def try_multiple_sources(sources):
    """מנסה מספר מקורות עד שאחד עובד"""
    for source in sources:
        try:
            return load_data_from_source(source)
        except ConnectionError:
            # השתקה מכוונת - רוצים לנסות מקור הבא
            logger.warning(f"Could not connect to {source}, trying next")
            continue
    
    raise RuntimeError("All sources failed")</pre>
                </div>
                
                <div class="code-bad">
                    <pre># השתקה לא מכוונת ומסוכנת
def load_config(filename):
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except Exception:  # מתעלם מכל דבר - לא ברור למה
        pass
    return {}  # לא ברור אם זה ברירת מחדל או בעיה

def process_user_input(user_input):
    try:
        result = dangerous_operation(user_input)
        return result
    except:  # השתקה גורפת - מסוכן!
        return "success"  # משקר למשתמש!

# דוגמה גרועה נוספת
def save_data(data):
    try:
        database.save(data)
    except:
        pass  # נתונים אבדו אבל אף אחד לא יודע!</pre>
                </div>
            </div>
        </div>

        <!-- Slide 14: Principle 12 -->
        <div class="slide hidden">
            <div class="zen-principle">12. In the face of ambiguity, refuse the temptation to guess</div>
            <div class="explanation">
                כשיש אי-בהירות, עדיף לא לנחש. עדיף לבקש הבהרה או לזרוק שגיאה מאשר לנחש ולטעות.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># לא מנחש - בוקש הבהרה
def format_date(date_input, format_type=None):
    """מפרמט תאריך עם הבהרה מפורשת של הפורמט"""
    
    if format_type is None:
        raise ValueError(
            "format_type must be specified: 'iso', 'us', or 'eu'"
        )
    
    if not isinstance(date_input, datetime):
        raise TypeError(
            "date_input must be datetime object"
        )
    
    format_map = {
        'iso': '%Y-%m-%d',
        'us': '%m/%d/%Y', 
        'eu': '%d/%m/%Y'
    }
    
    if format_type not in format_map:
        raise ValueError(
            f"Unknown format_type: {format_type}. "
            f"Supported: {list(format_map.keys())}"
        )
    
    return date_input.strftime(format_map[format_type])

# שימוש מפורש
date_str = format_date(datetime.now(), 'iso')</pre>
                </div>
                
                <div class="code-bad">
                    <pre># מנחש - מסוכן!
def format_date(date_input):
    """מנחש מה המשתמש רוצה - בעייתי!"""
    
    # ניחוש מסוכן על סמך locale
    import locale
    if locale.getdefaultlocale()[0].startswith('en_US'):
        return date_input.strftime('%m/%d/%Y')  # ניחוש!
    else:
        return date_input.strftime('%d/%m/%Y')  # ניחוש!

def parse_number_input(text):
    """מנחש מה המשתמש התכוון"""
    # ניחושים מסוכנים
    if '.' in text:
        return float(text)  # מה אם זה אלפים? 1.000 = 1000 או 1?
    elif ',' in text:
        # ניחוש - אולי אלפים אולי עשרוניות?
        return float(text.replace(',', '.'))
    else:
        return int(text)

# בעיות בפועל
print(parse_number_input("1.234"))  # 1.234 או 1234?
print(parse_number_input("3,14"))   # 3.14 או 314?</pre>
                </div>
            </div>
        </div>

        <!-- Slide 15: Principle 13 -->
        <div class="slide hidden">
            <div class="zen-principle">13. There should be one obvious way to do it</div>
            <div class="explanation">
                צריכה להיות דרך אחת ברורה לעשות דברים. Python מעדיף פתרון אחד ברור על הרבה פתרונות אפשריים.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># דרך אחת וברורה
def get_file_extension(filename):
    """מחזיר את סוג הקובץ - דרך סטנדרטית אחת"""
    import os
    return os.path.splitext(filename)[1].lower()

def read_text_file(filepath):
    """קורא קובץ טקסט - הדרך המומלצת"""
    with open(filepath, 'r', encoding='utf-8') as file:
        return file.read()

def create_list_from_range(start, end):
    """יוצר רשימה מטווח - הדרך הפייתונית"""
    return list(range(start, end))

# שימוש עקבי
extension = get_file_extension("document.txt")
content = read_text_file("data.txt")
numbers = create_list_from_range(1, 11)</pre>
                </div>
                
                <div class="code-bad">
                    <pre># הרבה דרכים שונות - מבלבל
def get_file_extension_v1(filename):
    return filename.split('.')[-1].lower()

def get_file_extension_v2(filename):
    import os
    return os.path.splitext(filename)[1][1:].lower()

def get_file_extension_v3(filename):
    parts = filename.rsplit('.', 1)
    return parts[1].lower() if len(parts) > 1 else ''

def get_file_extension_v4(filename):
    import pathlib
    return pathlib.Path(filename).suffix[1:].lower()

# איך לדעת איזה לבחור? מבלבל!
# כל מתכנת עושה אחרת
ext1 = get_file_extension_v1("test.txt")
ext2 = filename.split('.')[-1]  # עוד דרך
ext3 = filename[filename.rfind('.'):] # ועוד אחת</pre>
                </div>
            </div>
        </div>

        <!-- Slide 16: Principle 14 -->
        <div class="slide hidden">
            <div class="zen-principle">14. Although that way may not be obvious at first unless you're Dutch</div>
            <div class="explanation">
                רמז הומוריסטי ל-Guido van Rossum (יוצר Python) שהוא הולנדי. לפעמים הדרך הטובה לא ברורה מיד לכולם, אבל עם הזמן היא הופכת טבעית.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># "הדרך ההולנדית" - נראית מוזרה בהתחלה אבל גאונית
def fibonacci_pythonic():
    """סדרת פיבונאצ'י בדרך הפייתונית"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

def get_first_n_fibonacci(n):
    """מחזיר n המספרים הראשונים בסדרת פיבונאצ'י"""
    fib_gen = fibonacci_pythonic()
    return [next(fib_gen) for _ in range(n)]

# list comprehension עם enumerate - "הולנדי" אבל חכם
def process_with_index(items):
    return [f"{i}: {item.upper()}" 
            for i, item in enumerate(items) 
            if len(item) > 3]

# unpacking מתקדם - נראה מוזר אבל יעיל
def swap_and_process(pairs):
    """מחליף זוגות ומעבד אותם"""
    return [(b, a, a + b) for a, b in pairs]

# שימוש
fib_numbers = get_first_n_fibonacci(10)
processed = process_with_index(["hi", "hello", "world", "python"])
swapped = swap_and_process([(1, 2), (3, 4), (5, 6)])</pre>
                </div>
                
                <div class="code-bad">
                    <pre># גישה לא פייתונית - "לא הולנדית"
def fibonacci_not_pythonic():
    """פיבונאצ'י בדרך לא פייתונית"""
    def fib_recursive(n):
        if n <= 1:
            return n
        return fib_recursive(n-1) + fib_recursive(n-2)
    
    return fib_recursive

def get_first_n_fibonacci_bad(n):
    """גרסה לא יעילה וחסרת pythonic style"""
    result = []
    fib_func = fibonacci_not_pythonic()
    
    for i in range(n):
        result.append(fib_func(i))
    
    return result

def process_with_index_bad(items):
    """ללא enumerate - כמו בשפות אחרות"""
    result = []
    for i in range(len(items)):
        if len(items[i]) > 3:
            result.append(f"{i}: {items[i].upper()}")
    return result

# איטי ולא אלגנטי
fib_numbers = get_first_n_fibonacci_bad(10)  # מאוד איטי!</pre>
                </div>
            </div>
        </div>

        <!-- Slide 17: Principle 15 -->
        <div class="slide hidden">
            <div class="zen-principle">15. Now is better than never</div>
            <div class="explanation">
                עכשיו זה עדיף על אף פעם. עדיף לכתוב קוד שעובד עכשיו מאשר לחכות לפתרון המושלם שאולי לא יגיע.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># מתחיל עם פתרון פשוט שעובד
def simple_cache():
    """cache פשוט שעובד מיד"""
    _cache = {}
    
    def get(key):
        return _cache.get(key)
    
    def set(key, value):
        _cache[key] = value
    
    def clear():
        _cache.clear()
    
    return {'get': get, 'set': set, 'clear': clear}

# פתרון מהיר למטלה דחופה
def quick_data_export(data, filename):
    """ייצוא מהיר לCSV"""
    import csv
    
    with open(filename, 'w', newline='', encoding='utf-8') as file:
        if not data:
            return
        
        writer = csv.writer(file)
        
        # כותר
        if isinstance(data[0], dict):
            writer.writerow(data[0].keys())
            for row in data:
                writer.writerow(row.values())
        else:
            # רשימות פשוטות
            for row in data:
                writer.writerow(row)

# משתמש מיד בפתרון הפשוט
cache = simple_cache()
cache['set']('user_1', {'name': 'Alice', 'age': 30})</pre>
                </div>
                
                <div class="code-bad">
                    <pre># מחכה לפתרון "מושלם" שלא מגיע
class PerfectCacheSystem:
    """מערכת cache "מושלמת" שלא מסתיימת לפיתוח"""
    
    def __init__(self):
        # TODO: implement advanced caching strategies
        # TODO: add LRU eviction
        # TODO: add persistence 
        # TODO: add distributed caching
        # TODO: add metrics and monitoring
        # TODO: add compression
        # TODO: add encryption
        # TODO: add clustering support
        pass
    
    def get(self, key):
        # TODO: implement perfect retrieval logic
        raise NotImplementedError("Still designing the perfect solution")
    
    def set(self, key, value):
        # TODO: implement perfect storage logic  
        raise NotImplementedError("Still working on the architecture")

# בינתיים, אף אחד לא יכול להשתמש בזה
# המשרד מחכה, הפרויקט עומד, והלקוחות כועסים
# cache = PerfectCacheSystem()  # לא עובד כלום!

# או גרוע מזה - אובססיה למטא-פרוגרמינג מיותר
def over_engineered_solution():
    """פתרון מוגזם לבעיה פשוטה"""
    class MetaPerfectClass(type):
        def __new__(cls, name, bases, attrs):
            # TODO: add perfect metaclass magic
            return super().__new__(cls, name, bases, attrs)
    
    # עדיין לא עובד אחרי חודשיים...</pre>
                </div>
            </div>
        </div>

        <!-- Slide 18: Principle 16 -->
        <div class="slide hidden">
            <div class="zen-principle">16. Although never is often better than *right* now</div>
            <div class="explanation">
                אבל "אף פעם" לעיתים קרובות עדיף על "ממש עכשיו". לא כדאי לחפז מדי - לפעמים עדיף להמתין ולחשוב טוב.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># לוקח זמן לחשוב על הפתרון הנכון
def well_thought_user_system():
    """מערכת משתמשים מתוכננת היטב"""
    
    # חשבתי על הצרכים ותכננתי מראש
    class User:
        def __init__(self, username, email):
            self.username = self._validate_username(username)
            self.email = self._validate_email(email)
            self.created_at = datetime.now()
            self.is_active = True
        
        def _validate_username(self, username):
            if not username or len(username) < 3:
                raise ValueError("Username must be at least 3 characters")
            return username.strip().lower()
        
        def _validate_email(self, email):
            if '@' not in email or '.' not in email:
                raise ValueError("Invalid email format")
            return email.strip().lower()
    
    class UserManager:
        def __init__(self):
            self.users = {}
        
        def create_user(self, username, email):
            if username in self.users:
                raise ValueError("Username already exists")
            
            user = User(username, email)
            self.users[username] = user
            return user
        
        def get_user(self, username):
            return self.users.get(username)
    
    return UserManager()</pre>
                </div>
                
                <div class="code-bad">
                    <pre># פתרון נחפז שגורם לבעיות
def rushed_solution():
    """פתרון נחפז שגורם לבעיות"""
    
    # נחפזתי וכתבתי קוד גרוע
    users = {}  # משתנה גלובלי - בעייתי!
    
    def add_user(name, mail):
        users[name] = mail  # ללא validation!
        return "OK"
    
    def get_user_mail(name):
        return users[name]  # יכול להיכשל!
    
    # התוצאה: bugs וכאבי ראש
    return add_user, get_user_mail

# בעיות שנוצרות מחיפזון:
add_user, get_mail = rushed_solution()

# שמות זהים מחליפים משתמשים
add_user("john", "john@email.com")
add_user("john", "different@email.com")  # אופס!

# אין validation
add_user("", "not-an-email")  # אופס!
add_user(None, None)  # אופס!

# crashes על משתמש לא קיים  
try:
    email = get_mail("nonexistent")  # KeyError!
except KeyError:
    print("הפתרון הנחפז גרם לבאג!")

# עכשיו צריך לתקן הכל מהתחלה...</pre>
                </div>
            </div>
        </div>

        <!-- Slide 19: Principle 17 -->
        <div class="slide hidden">
            <div class="zen-principle">17. If the implementation is hard to explain, it's a bad idea</div>
            <div class="explanation">
                אם קשה להסביר את המימוש, זה רעיון רע. קוד טוב צריך להיות פשוט מספיק כדי שאפשר יהיה להסביר אותו בקלות.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># קל להסביר - רעיון טוב
def simple_word_counter(text):
    """סופר מילים - קל להסביר ולהבין"""
    # 1. מפצל טקסט למילים
    words = text.lower().split()
    
    # 2. סופר כל מילה
    word_count = {}
    for word in words:
        # מסיר סימני פיסוק בסיסיים
        clean_word = word.strip('.,!?;:"')
        
        if clean_word:  # רק מילים לא ריקות
            word_count[clean_word] = word_count.get(clean_word, 0) + 1
    
    return word_count

def get_most_common_words(word_count, top_n=5):
    """מחזיר המילים הנפוצות ביותר"""
    # ממיין לפי כמות (מהגדול לקטן)
    sorted_words = sorted(
        word_count.items(), 
        key=lambda item: item[1], 
        reverse=True
    )
    
    # מחזיר רק המילים המבוקשות
    return sorted_words[:top_n]

# קל להבין מה הקוד עושה:
text = "Python is great. Python is powerful. Great and powerful."
counts = simple_word_counter(text)
top_words = get_most_common_words(counts, 3)</pre>
                </div>
                
                <div class="code-bad">
                    <pre># קשה להסביר - רעיון רע
def complex_word_analyzer(text):
    """מנתח מילים בצורה מורכבת מדי - קשה להסביר"""
    
    # אף אחד לא יבין מה קורה כאן...
    from collections import defaultdict, Counter
    import re
    
    # meta-class pattern שלא מוסיף כלום
    class WordAnalyzerMeta(type):
        def __new__(cls, name, bases, attrs):
            attrs['_secret_method'] = lambda self, x: x.lower()
            return super().__new__(cls, name, bases, attrs)
    
    class ComplexAnalyzer(metaclass=WordAnalyzerMeta):
        def __init__(self):
            self.patterns = [
                (re.compile(r'\b\w+\b'), lambda m: m.group().lower()),
                (re.compile(r'[^\w\s]'), lambda m: ''),
            ]
            self._cache = defaultdict(lambda: defaultdict(int))
        
        def analyze(self, text):
            # לולאה מסובכת עם nested comprehensions
            result = Counter([
                self._secret_method(match.group())
                for pattern, transform in self.patterns
                for match in pattern.finditer(text)
                if transform(match) and len(transform(match)) > 0
            ])
            
            # עוד לוגיקה מסובכת
            return {k: v for k, v in 
                   sorted(result.items(), 
                         key=lambda x: (x[1], len(x[0])), 
                         reverse=True)
                   if k.isalpha()}
    
    # אף אחד לא יבין איך להשתמש בזה
    analyzer = ComplexAnalyzer()
    return analyzer.analyze(text)</pre>
                </div>
            </div>
        </div>

        <!-- Slide 20: Principle 18 -->
        <div class="slide hidden">
            <div class="zen-principle">18. If the implementation is easy to explain, it may be a good idea</div>
            <div class="explanation">
                אם קל להסביר את המימוש, יכול להיות שזה רעיון טוב. פשטות היא סימן לעיצוב טוב, אבל לא ערובה.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># קל להסביר ואכן רעיון טוב
def simple_password_validator(password):
    """בודק חוזק סיסמה - קל להסביר ויעיל"""
    
    if len(password) < 8:
        return False, "Password must be at least 8 characters"
    
    has_upper = any(c.isupper() for c in password)
    has_lower = any(c.islower() for c in password) 
    has_digit = any(c.isdigit() for c in password)
    has_special = any(c in "!@#$%^&*" for c in password)
    
    checks = [has_upper, has_lower, has_digit, has_special]
    
    if sum(checks) < 3:
        return False, "Password must contain at least 3 types: uppercase, lowercase, digits, special chars"
    
    return True, "Password is strong"

def create_user_account(username, password, email):
    """יוצר חשבון משתמש עם validations בסיסיים"""
    
    # בדיקת username
    if not username or len(username) < 3:
        raise ValueError("Username must be at least 3 characters")
    
    # בדיקת password
    is_valid, message = simple_password_validator(password)
    if not is_valid:
        raise ValueError(f"Password error: {message}")
    
    # בדיקת email פשוטה
    if '@' not in email or '.' not in email.split('@')[-1]:
        raise ValueError("Invalid email format")
    
    return {
        'username': username,
        'email': email,
        'created_at': datetime.now().isoformat()
    }</pre>
                </div>
                
                <div class="code-bad">
                    <pre># קל להסביר אבל רעיון גרוע
def overly_simple_validator(password):
    """פשוט מדי - לא מספיק טוב"""
    # "קל להסביר" אבל לא יעיל
    return len(password) > 4  # זה הכל?!

def naive_email_check(email):
    """פשוט אבל לא מעשי"""
    return '@' in email  # גם "abc@" יעבור!

def basic_user_storage():
    """פשוט להבנה אבל בעייתי בפועל"""
    users = []  # list במקום dict - איטי לחיפושים!
    
    def add_user(name, email):
        users.append((name, email))  # אין בדיקת כפילויות
    
    def find_user(name):
        # O(n) complexity - איטי!
        for user_name, user_email in users:
            if user_name == name:
                return user_email
        return None
    
    def delete_user(name):
        # עוד O(n) + מסובך
        global users
        users = [(n, e) for n, e in users if n != name]
    
    return add_user, find_user, delete_user

# נראה פשוט אבל יוצר בעיות:
add_user, find_user, delete_user = basic_user_storage()

# מאפשר כפילויות
add_user("john", "john@email.com")  
add_user("john", "john2@email.com")  # אופס!

# איטי עם הרבה משתמשים
# find_user("john")  # איזה מתוך השניים?</pre>
                </div>
            </div>
        </div>

        <!-- Slide 21: Principle 19 -->
        <div class="slide hidden">
            <div class="zen-principle">19. Namespaces are one honking great idea -- let's do more of those!</div>
            <div class="explanation">
                מרחבי שמות (Namespaces) הם רעיון נפלא! הם עוזרים למנוע התנגשויות ולארגן קוד בצורה הגיונית. Python מעודד שימוש במרחבי שמות.
            </div>
            
            <div class="code-section">
                <div class="code-good">
                    <pre># שימוש נכון במרחבי שמות
# file: math_utils.py
class Statistics:
    """מרחב שמות לפונקציות סטטיסטיקה"""
    
    @staticmethod
    def mean(numbers):
        return sum(numbers) / len(numbers)
    
    @staticmethod  
    def median(numbers):
        sorted_nums = sorted(numbers)
        n = len(sorted_nums)
        mid = n // 2
        if n % 2 == 0:
            return (sorted_nums[mid-1] + sorted_nums[mid]) / 2
        return sorted_nums[mid]

class StringUtils:
    """מרחב שמות לעזרי מחרוזות"""
    
    @staticmethod
    def reverse_words(text):
        return ' '.join(word[::-1] for word in text.split())
    
    @staticmethod
    def title_case(text):
        return text.title()

# file: main.py
from math_utils import Statistics, StringUtils

# ברור מאיפה כל פונקציה מגיעה
data = [1, 2, 3, 4, 5]
average = Statistics.mean(data)
middle = Statistics.median(data)

text = "hello world"
reversed_text = StringUtils.reverse_words(text)

# או עם modules
import datetime
import json
import pathlib

# ברור מאיפה כל פונקציה
current_time = datetime.datetime.now()
data = json.loads('{"key": "value"}')
file_path = pathlib.Path("data.txt")</pre>
                </div>
                
                <div class="code-bad">
                    <pre># ללא namespaces - בלגן ומסוכן
# הכל במרחב השמות הגלובלי - מסוכן!

def mean(numbers):
    return sum(numbers) / len(numbers)

def median(numbers):
    # ... implementation

def reverse_words(text):
    return ' '.join(word[::-1] for word in text.split())

def title_case(text):
    return text.title()

# import מסוכן
from datetime import *  # מזהם את המרחב הגלובלי!
from math import *      # יכול לדרוס פונקציות!
from json import *

# בעיות שנוצרות:
# 1. אי אפשר לדעת מאיפה פונקציה מגיעה
result = mean([1, 2, 3])  # איזה mean? שלנו או של numpy?

# 2. התנגשויות שמות
def sum(numbers):  # אופס! דרסנו את sum המובנית!
    return "my custom sum"

# עכשיו sum() לא עובדת כמו שצריך
total = sum([1, 2, 3])  # מחזיר "my custom sum" ?!

# 3. import * מסוכן
from some_library import *  # מה בדיוק יובא?
# יכול לדרוס משתנים ופונקציות קיימות

# 4. קשה לנהל בפרויקט גדול
# אף אחד לא יודע איפה מוגדרת כל פונקציה</pre>
                </div>
            </div>
        </div>

        <!-- Slide 22: Summary -->
        <div class="slide hidden">
            <h2 style="font-size: 2.5em; margin-bottom: 30px; color: #2c3e50; text-align: center;">סיכום ה-Zen of Python</h2>
            <div class="explanation">
                <h3 style="color: #6c5ce7; margin-bottom: 20px;">העקרונות המרכזיים:</h3>
                <ul style="list-style-type: none; padding-right: 20px; font-size: 1.1em;">
                    <li style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-right: 4px solid #74b9ff; border-radius: 5px;">
                        💎 <strong>יופי וקריאות:</strong> קוד צריך להיות יפה, ברור וקריא
                    </li>
                    <li style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-right: 4px solid #00b894; border-radius: 5px;">
                        🎯 <strong>פשטות:</strong> פשוט עדיף על מורכב, מורכב עדיף על מסובך
                    </li>
                    <li style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-right: 4px solid #fdcb6e; border-radius: 5px;">
                        🔍 <strong>בהירות:</strong> מפורש עדיף על מרומז, אל תנחש במקרי אי-בהירות
                    </li>
                    <li style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-right: 4px solid #fd79a8; border-radius: 5px;">
                        ⚠️ <strong>טיפול בשגיאות:</strong> שגיאות לא צריכות לעבור בדממה
                    </li>
                    <li style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-right: 4px solid #a29bfe; border-radius: 5px;">
                        🏗️ <strong>ארגון:</strong> namespaces רעיון מעולה, מבנה שטוח עדיף על מקונן
                    </li>
                    <li style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-right: 4px solid #6c5ce7; border-radius: 5px;">
                        ⏰ <strong>פרגמטיות:</strong> עכשיו עדיף על אף פעם, אבל לא בחיפזון מדי
                    </li>
                </ul>
                
                <div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 25px; border-radius: 15px; margin-top: 30px; text-align: center;">
                    <h3 style="margin-bottom: 15px; font-size: 1.5em;">זכרו: הקוד נכתב פעם אחת אבל נקרא פעמים רבות!</h3>
                    <p style="font-size: 1.2em; opacity: 0.9;">
                        השקיעו בקריאות, פשטות ובהירות - זה ישתלם לכם ולמי שיקרא את הקוד אחריכם
                    </p>
                </div>
                
                <div style="margin-top: 30px; text-align: center; font-size: 1.1em;">
                    <p><strong>איך לראות את הזן בקוד Python:</strong></p>
                    <pre style="background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 8px; margin: 10px 0; display: inline-block;">import this</pre>
                </div>
            </div>
        </div>
    </div>

    <div class="navigation">
        <button class="nav-btn" onclick="previousSlide()" id="prevBtn">← קודם</button>
        <button class="nav-btn" onclick="nextSlide()" id="nextBtn">הבא →</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const totalSlides = slides.length;
        
        document.getElementById('total-slides').textContent = totalSlides;

        function showSlide(n) {
            slides.forEach(slide => slide.classList.add('hidden'));
            slides[n].classList.remove('hidden');
            
            document.getElementById('current-slide').textContent = n + 1;
            
            // Update navigation buttons
            document.getElementById('prevBtn').disabled = n === 0;
            document.getElementById('nextBtn').disabled = n === totalSlides - 1;
            
            // Scroll to top of slide
            slides[n].scrollIntoView({ behavior: 'smooth' });
        }

        function nextSlide() {
            if (currentSlide < totalSlides - 1) {
                currentSlide++;
                showSlide(currentSlide);
            }
        }

        function previousSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                showSlide(currentSlide);
            }
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                previousSlide();
            }
        });

        // Initialize
        showSlide(0);

        // Add smooth scroll behavior for better UX
        document.documentElement.style.scrollBehavior = 'smooth';
    </script>
</body>
</html>